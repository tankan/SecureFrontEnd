# üõ°Ô∏è ÂÆâÂÖ®ÊúÄ‰Ω≥ÂÆûË∑µÊåáÂçó

Êú¨ÊåáÂçóËØ¶ÁªÜ‰ªãÁªç‰∫Ü SecureFrontEnd Â∫îÁî®Á®ãÂ∫èÁöÑÂÆâÂÖ®ÁâπÊÄß„ÄÅÈÖçÁΩÆÂíåÊúÄ‰Ω≥ÂÆûË∑µÔºåÂ∏ÆÂä©ÊÇ®ÊûÑÂª∫ÂíåÁª¥Êä§‰∏Ä‰∏™ÂÆâÂÖ®ÁöÑÂ∫îÁî®ÁéØÂ¢É„ÄÇ

## üìã ÂÆâÂÖ®Ê¶ÇËø∞

SecureFrontEnd ÈááÁî®Â§öÂ±ÇÂÆâÂÖ®Êû∂ÊûÑÔºåÂåÖÊã¨Ôºö

- **Ë∫´‰ªΩËÆ§ËØÅÂíåÊéàÊùÉ** - JWT ‰ª§ÁâåÂíåÂü∫‰∫éËßíËâ≤ÁöÑËÆøÈóÆÊéßÂà∂
- **Êï∞ÊçÆÂä†ÂØÜ** - ‰º†ËæìÂíåÂ≠òÂÇ®Âä†ÂØÜ
- **ËæìÂÖ•È™åËØÅ** - ‰∏•Ê†ºÁöÑÊï∞ÊçÆÈ™åËØÅÂíåÊ∏ÖÁêÜ
- **ÂÆâÂÖ®ÁõëÊéß** - ÂÆûÊó∂Â®ÅËÉÅÊ£ÄÊµãÂíåÊó•ÂøóËÆ∞ÂΩï
- **ÂêàËßÑÊÄß** - Á¨¶Âêà GDPR„ÄÅHIPAA Á≠âÊ†áÂáÜ

## üîê Ë∫´‰ªΩËÆ§ËØÅÂíåÊéàÊùÉ

### JWT ‰ª§ÁâåÈÖçÁΩÆ

#### ÁîüÊàêÂÆâÂÖ®ÁöÑ JWT ÂØÜÈí•

```bash
# ÁîüÊàê 256 ‰ΩçÈöèÊú∫ÂØÜÈí•
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"

# Êàñ‰ΩøÁî® OpenSSL
openssl rand -hex 32
```

#### JWT ÈÖçÁΩÆÊúÄ‰Ω≥ÂÆûË∑µ

```javascript
// config/jwt.js
const jwtConfig = {
  secret: process.env.JWT_SECRET, // Ëá≥Â∞ë 32 Â≠óÁ¨¶
  expiresIn: '15m',              // Áü≠ÊúüËÆøÈóÆ‰ª§Áâå
  refreshExpiresIn: '7d',        // Âà∑Êñ∞‰ª§Áâå
  algorithm: 'HS256',            // Êé®ËçêÁÆóÊ≥ï
  issuer: 'SecureFrontEnd',      // ‰ª§ÁâåÂèëË°åËÄÖ
  audience: 'api.securefrontend.com' // ÁõÆÊ†áÂèó‰ºó
};
```

#### ‰ª§ÁâåÂà∑Êñ∞Êú∫Âà∂

```javascript
// Ëá™Âä®Âà∑Êñ∞‰ª§Áâå
class TokenManager {
  async refreshToken(refreshToken) {
    try {
      const decoded = jwt.verify(refreshToken, process.env.REFRESH_SECRET);
      const user = await User.findById(decoded.userId);
      
      if (!user || !user.isActive) {
        throw new Error('Invalid user');
      }
      
      // ÁîüÊàêÊñ∞ÁöÑËÆøÈóÆ‰ª§Áâå
      const accessToken = this.generateAccessToken(user);
      const newRefreshToken = this.generateRefreshToken(user);
      
      // Êí§ÈîÄÊóßÁöÑÂà∑Êñ∞‰ª§Áâå
      await this.revokeRefreshToken(refreshToken);
      
      return { accessToken, refreshToken: newRefreshToken };
    } catch (error) {
      throw new Error('Token refresh failed');
    }
  }
}
```

### Âü∫‰∫éËßíËâ≤ÁöÑËÆøÈóÆÊéßÂà∂ (RBAC)

#### ËßíËâ≤ÂÆö‰πâ

```javascript
// models/Role.js
const roles = {
  SUPER_ADMIN: {
    name: 'super_admin',
    permissions: ['*'] // ÊâÄÊúâÊùÉÈôê
  },
  ADMIN: {
    name: 'admin',
    permissions: [
      'users:read', 'users:write', 'users:delete',
      'modules:read', 'modules:write',
      'security:read', 'security:write'
    ]
  },
  USER: {
    name: 'user',
    permissions: [
      'profile:read', 'profile:write',
      'data:read'
    ]
  },
  GUEST: {
    name: 'guest',
    permissions: ['public:read']
  }
};
```

#### ÊùÉÈôê‰∏≠Èó¥‰ª∂

```javascript
// middleware/auth.js
const requirePermission = (permission) => {
  return async (req, res, next) => {
    try {
      const token = req.headers.authorization?.split(' ')[1];
      if (!token) {
        return res.status(401).json({ error: 'No token provided' });
      }
      
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const user = await User.findById(decoded.userId).populate('role');
      
      if (!user || !user.isActive) {
        return res.status(401).json({ error: 'Invalid user' });
      }
      
      // Ê£ÄÊü•ÊùÉÈôê
      if (!hasPermission(user.role.permissions, permission)) {
        return res.status(403).json({ error: 'Insufficient permissions' });
      }
      
      req.user = user;
      next();
    } catch (error) {
      return res.status(401).json({ error: 'Invalid token' });
    }
  };
};
```

## üîí Êï∞ÊçÆÂä†ÂØÜ

### ‰º†ËæìÂä†ÂØÜ (TLS/SSL)

#### SSL ËØÅ‰π¶ÈÖçÁΩÆ

```javascript
// server/https.js
const https = require('https');
const fs = require('fs');

const sslOptions = {
  key: fs.readFileSync('/path/to/private-key.pem'),
  cert: fs.readFileSync('/path/to/certificate.pem'),
  ca: fs.readFileSync('/path/to/ca-bundle.pem'), // ÂèØÈÄâ
  
  // ÂÆâÂÖ®ÈÖçÁΩÆ
  secureProtocol: 'TLSv1_2_method',
  ciphers: [
    'ECDHE-RSA-AES256-GCM-SHA384',
    'ECDHE-RSA-AES128-GCM-SHA256',
    'ECDHE-RSA-AES256-SHA384',
    'ECDHE-RSA-AES128-SHA256'
  ].join(':'),
  honorCipherOrder: true
};

const server = https.createServer(sslOptions, app);
```

#### HTTP ÂÆâÂÖ®Â§¥

```javascript
// middleware/security.js
const helmet = require('helmet');

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));
```

### Â≠òÂÇ®Âä†ÂØÜ

#### Êï∞ÊçÆÂ∫ìÂ≠óÊÆµÂä†ÂØÜ

```javascript
// utils/encryption.js
const crypto = require('crypto');

class FieldEncryption {
  constructor() {
    this.algorithm = 'aes-256-gcm';
    this.key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');
  }
  
  encrypt(text) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, this.key, iv);
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex')
    };
  }
  
  decrypt(encryptedData) {
    const decipher = crypto.createDecipher(
      this.algorithm,
      this.key,
      Buffer.from(encryptedData.iv, 'hex')
    );
    
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}
```

#### ÊïèÊÑüÊï∞ÊçÆÂ§ÑÁêÜ

```javascript
// models/User.js
const bcrypt = require('bcrypt');

class User {
  // ÂØÜÁ†ÅÂìàÂ∏å
  static async hashPassword(password) {
    const saltRounds = 12;
    return await bcrypt.hash(password, saltRounds);
  }
  
  // ÂØÜÁ†ÅÈ™åËØÅ
  async verifyPassword(password) {
    return await bcrypt.compare(password, this.passwordHash);
  }
  
  // ÊïèÊÑüÂ≠óÊÆµÂä†ÂØÜ
  encryptSensitiveData() {
    const encryption = new FieldEncryption();
    
    if (this.ssn) {
      this.encryptedSSN = encryption.encrypt(this.ssn);
      delete this.ssn;
    }
    
    if (this.creditCard) {
      this.encryptedCreditCard = encryption.encrypt(this.creditCard);
      delete this.creditCard;
    }
  }
}
```

## üõ°Ô∏è ËæìÂÖ•È™åËØÅÂíåÊ∏ÖÁêÜ

### Êï∞ÊçÆÈ™åËØÅ

```javascript
// validators/userValidator.js
const Joi = require('joi');
const validator = require('validator');

const userSchema = Joi.object({
  username: Joi.string()
    .alphanum()
    .min(3)
    .max(30)
    .required(),
    
  email: Joi.string()
    .email()
    .required()
    .custom((value, helpers) => {
      if (!validator.isEmail(value)) {
        return helpers.error('any.invalid');
      }
      return value;
    }),
    
  password: Joi.string()
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\$%\^&\*])'))
    .required()
    .messages({
      'string.pattern.base': 'Password must contain at least one lowercase letter, one uppercase letter, one number, and one special character'
    }),
    
  phone: Joi.string()
    .pattern(/^\+?[1-9]\d{1,14}$/)
    .optional()
});

const validateUser = (req, res, next) => {
  const { error } = userSchema.validate(req.body);
  if (error) {
    return res.status(400).json({
      error: 'Validation failed',
      details: error.details.map(d => d.message)
    });
  }
  next();
};
```

### SQL Ê≥®ÂÖ•Èò≤Êä§

```javascript
// ‰ΩøÁî®ÂèÇÊï∞ÂåñÊü•ËØ¢
const getUserById = async (userId) => {
  // Ê≠£Á°ÆÁöÑÊñπÂºè
  const query = 'SELECT * FROM users WHERE id = $1';
  const result = await db.query(query, [userId]);
  return result.rows[0];
};

// ‰ΩøÁî® ORM
const User = require('./models/User');
const user = await User.findOne({
  where: { id: userId },
  attributes: { exclude: ['passwordHash'] }
});
```

### XSS Èò≤Êä§

```javascript
// utils/sanitizer.js
const DOMPurify = require('isomorphic-dompurify');
const validator = require('validator');

class InputSanitizer {
  static sanitizeHTML(input) {
    return DOMPurify.sanitize(input, {
      ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br'],
      ALLOWED_ATTR: []
    });
  }
  
  static escapeHTML(input) {
    return validator.escape(input);
  }
  
  static sanitizeJSON(obj) {
    const sanitized = {};
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'string') {
        sanitized[key] = this.escapeHTML(value);
      } else if (typeof value === 'object' && value !== null) {
        sanitized[key] = this.sanitizeJSON(value);
      } else {
        sanitized[key] = value;
      }
    }
    return sanitized;
  }
}
```

## üîç ÂÆâÂÖ®ÁõëÊéß

### ÂÆâÂÖ®‰∫ã‰ª∂Êó•Âøó

```javascript
// services/SecurityLogger.js
class SecurityLogger {
  constructor() {
    this.winston = require('winston');
    this.logger = this.winston.createLogger({
      level: 'info',
      format: this.winston.format.combine(
        this.winston.format.timestamp(),
        this.winston.format.json()
      ),
      transports: [
        new this.winston.transports.File({ 
          filename: 'logs/security.log',
          level: 'warn'
        }),
        new this.winston.transports.File({ 
          filename: 'logs/security-error.log',
          level: 'error'
        })
      ]
    });
  }
  
  logSecurityEvent(event, details) {
    this.logger.warn('Security Event', {
      event,
      details,
      timestamp: new Date().toISOString(),
      ip: details.ip,
      userAgent: details.userAgent,
      userId: details.userId
    });
  }
  
  logFailedLogin(username, ip, userAgent) {
    this.logSecurityEvent('FAILED_LOGIN', {
      username,
      ip,
      userAgent,
      severity: 'medium'
    });
  }
  
  logSuspiciousActivity(activity, details) {
    this.logSecurityEvent('SUSPICIOUS_ACTIVITY', {
      activity,
      ...details,
      severity: 'high'
    });
  }
}
```

### ÂÖ•‰æµÊ£ÄÊµã

```javascript
// services/IntrusionDetection.js
class IntrusionDetection {
  constructor() {
    this.failedAttempts = new Map();
    this.suspiciousIPs = new Set();
    this.rateLimiter = new Map();
  }
  
  checkFailedLogins(ip, username) {
    const key = `${ip}:${username}`;
    const attempts = this.failedAttempts.get(key) || 0;
    
    if (attempts >= 5) {
      this.suspiciousIPs.add(ip);
      this.securityLogger.logSuspiciousActivity('BRUTE_FORCE_ATTEMPT', {
        ip,
        username,
        attempts
      });
      return false;
    }
    
    this.failedAttempts.set(key, attempts + 1);
    
    // Ê∏ÖÁêÜËøáÊúüËÆ∞ÂΩï
    setTimeout(() => {
      this.failedAttempts.delete(key);
    }, 15 * 60 * 1000); // 15ÂàÜÈíü
    
    return true;
  }
  
  checkRateLimit(ip, endpoint) {
    const key = `${ip}:${endpoint}`;
    const requests = this.rateLimiter.get(key) || [];
    const now = Date.now();
    
    // Ê∏ÖÁêÜËøáÊúüËØ∑Ê±Ç
    const validRequests = requests.filter(time => now - time < 60000); // 1ÂàÜÈíü
    
    if (validRequests.length >= 100) { // ÊØèÂàÜÈíüÊúÄÂ§ö100ËØ∑Ê±Ç
      this.securityLogger.logSuspiciousActivity('RATE_LIMIT_EXCEEDED', {
        ip,
        endpoint,
        requests: validRequests.length
      });
      return false;
    }
    
    validRequests.push(now);
    this.rateLimiter.set(key, validRequests);
    
    return true;
  }
}
```

## üîê ‰ºöËØùÁÆ°ÁêÜ

### ÂÆâÂÖ®‰ºöËØùÈÖçÁΩÆ

```javascript
// config/session.js
const session = require('express-session');
const RedisStore = require('connect-redis')(session);
const redis = require('redis');

const redisClient = redis.createClient({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

const sessionConfig = {
  store: new RedisStore({ client: redisClient }),
  secret: process.env.SESSION_SECRET,
  name: 'sessionId', // ‰∏ç‰ΩøÁî®ÈªòËÆ§ÂêçÁß∞
  resave: false,
  saveUninitialized: false,
  rolling: true, // ÊØèÊ¨°ËØ∑Ê±ÇÈáçÁΩÆËøáÊúüÊó∂Èó¥
  cookie: {
    secure: process.env.NODE_ENV === 'production', // HTTPS only
    httpOnly: true, // Èò≤Ê≠¢ XSS
    maxAge: 30 * 60 * 1000, // 30ÂàÜÈíü
    sameSite: 'strict' // CSRF ‰øùÊä§
  }
};

app.use(session(sessionConfig));
```

### ‰ºöËØùÂÆâÂÖ®‰∏≠Èó¥‰ª∂

```javascript
// middleware/sessionSecurity.js
const sessionSecurity = (req, res, next) => {
  // Ê£ÄÊü•‰ºöËØùÂä´ÊåÅ
  if (req.session.userAgent && req.session.userAgent !== req.get('User-Agent')) {
    req.session.destroy();
    return res.status(401).json({ error: 'Session security violation' });
  }
  
  // Ê£ÄÊü• IP ÂèòÂåñ
  if (req.session.ipAddress && req.session.ipAddress !== req.ip) {
    req.session.destroy();
    return res.status(401).json({ error: 'Session security violation' });
  }
  
  // ËÆæÁΩÆ‰ºöËØùÊåáÁ∫π
  if (!req.session.userAgent) {
    req.session.userAgent = req.get('User-Agent');
    req.session.ipAddress = req.ip;
  }
  
  next();
};
```

## üõ°Ô∏è CSRF ‰øùÊä§

```javascript
// middleware/csrf.js
const csrf = require('csurf');

const csrfProtection = csrf({
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  }
});

// ‰∏∫ API Êèê‰æõ CSRF ‰ª§Áâå
app.get('/api/csrf-token', csrfProtection, (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});

// ‰øùÊä§ÊâÄÊúâ POST/PUT/DELETE ËØ∑Ê±Ç
app.use('/api', csrfProtection);
```

## üìä ÂêàËßÑÊÄß

### GDPR ÂêàËßÑ

```javascript
// services/GDPRCompliance.js
class GDPRCompliance {
  // Êï∞ÊçÆÂØºÂá∫
  async exportUserData(userId) {
    const user = await User.findById(userId);
    const activities = await UserActivity.find({ userId });
    const preferences = await UserPreferences.find({ userId });
    
    return {
      personalData: {
        id: user.id,
        email: user.email,
        name: user.name,
        createdAt: user.createdAt
      },
      activities: activities.map(a => ({
        action: a.action,
        timestamp: a.timestamp,
        ip: a.ip
      })),
      preferences: preferences
    };
  }
  
  // Êï∞ÊçÆÂà†Èô§
  async deleteUserData(userId) {
    await User.findByIdAndDelete(userId);
    await UserActivity.deleteMany({ userId });
    await UserPreferences.deleteMany({ userId });
    await UserSessions.deleteMany({ userId });
    
    // ËÆ∞ÂΩïÂà†Èô§Êìç‰Ωú
    await AuditLog.create({
      action: 'USER_DATA_DELETED',
      userId,
      timestamp: new Date(),
      reason: 'GDPR_REQUEST'
    });
  }
  
  // ÂêåÊÑèÁÆ°ÁêÜ
  async recordConsent(userId, consentType, granted) {
    await ConsentRecord.create({
      userId,
      consentType,
      granted,
      timestamp: new Date(),
      ip: req.ip,
      userAgent: req.get('User-Agent')
    });
  }
}
```

### ÂÆ°ËÆ°Êó•Âøó

```javascript
// services/AuditLogger.js
class AuditLogger {
  async logDataAccess(userId, dataType, action, details) {
    await AuditLog.create({
      userId,
      action: `DATA_${action.toUpperCase()}`,
      dataType,
      details,
      timestamp: new Date(),
      ip: details.ip,
      userAgent: details.userAgent
    });
  }
  
  async logAdminAction(adminId, action, target, details) {
    await AuditLog.create({
      userId: adminId,
      action: `ADMIN_${action.toUpperCase()}`,
      target,
      details,
      timestamp: new Date(),
      severity: 'high'
    });
  }
  
  async generateComplianceReport(startDate, endDate) {
    const logs = await AuditLog.find({
      timestamp: { $gte: startDate, $lte: endDate }
    });
    
    return {
      period: { startDate, endDate },
      totalEvents: logs.length,
      dataAccess: logs.filter(l => l.action.startsWith('DATA_')).length,
      adminActions: logs.filter(l => l.action.startsWith('ADMIN_')).length,
      securityEvents: logs.filter(l => l.severity === 'high').length
    };
  }
}
```

## üîß ÂÆâÂÖ®ÈÖçÁΩÆÊ£ÄÊü•Ê∏ÖÂçï

### Â∫îÁî®ÈÖçÁΩÆ
- [ ] JWT ÂØÜÈí•ÈïøÂ∫¶Ëá≥Â∞ë 32 Â≠óÁ¨¶
- [ ] ÂØÜÁ†ÅÂìàÂ∏å‰ΩøÁî® bcryptÔºåËΩÆÊï∞Ëá≥Â∞ë 12
- [ ] ‰ºöËØùÈÖçÁΩÆÂÆâÂÖ®ÔºàhttpOnly, secure, sameSiteÔºâ
- [ ] CSRF ‰øùÊä§Â∑≤ÂêØÁî®
- [ ] ËæìÂÖ•È™åËØÅÂíåÊ∏ÖÁêÜÂ∑≤ÂÆûÊñΩ
- [ ] SQL Ê≥®ÂÖ•Èò≤Êä§Â∑≤ÂÆûÊñΩ
- [ ] XSS Èò≤Êä§Â∑≤ÂÆûÊñΩ

### ÊúçÂä°Âô®ÈÖçÁΩÆ
- [ ] HTTPS Â∑≤ÂêØÁî®
- [ ] ÂÆâÂÖ®Â§¥Â∑≤ÈÖçÁΩÆ
- [ ] Èò≤ÁÅ´Â¢ôËßÑÂàôÂ∑≤ËÆæÁΩÆ
- [ ] ‰∏çÂøÖË¶ÅÁöÑÊúçÂä°Â∑≤Á¶ÅÁî®
- [ ] Á≥ªÁªüÊõ¥Êñ∞Â∑≤ÂÆâË£Ö
- [ ] Êó•ÂøóËÆ∞ÂΩïÂ∑≤ÈÖçÁΩÆ

### Êï∞ÊçÆÂ∫ìÂÆâÂÖ®
- [ ] Êï∞ÊçÆÂ∫ìÁî®Êà∑ÊùÉÈôêÊúÄÂ∞èÂåñ
- [ ] ÊïèÊÑüÊï∞ÊçÆÂ∑≤Âä†ÂØÜ
- [ ] Êï∞ÊçÆÂ∫ìËøûÊé•Â∑≤Âä†ÂØÜ
- [ ] Â§á‰ªΩÂ∑≤Âä†ÂØÜ
- [ ] ËÆøÈóÆÊó•ÂøóÂ∑≤ÂêØÁî®

### ÁõëÊéßÂíåÂìçÂ∫î
- [ ] ÂÆâÂÖ®‰∫ã‰ª∂ÁõëÊéßÂ∑≤ÂêØÁî®
- [ ] ÂÖ•‰æµÊ£ÄÊµãÁ≥ªÁªüÂ∑≤ÈÖçÁΩÆ
- [ ] Êó•ÂøóÂàÜÊûêÂ∑≤ËÆæÁΩÆ
- [ ] ‰∫ã‰ª∂ÂìçÂ∫îËÆ°ÂàíÂ∑≤Âà∂ÂÆö
- [ ] ÂÆöÊúüÂÆâÂÖ®ÂÆ°ËÆ°Â∑≤ÂÆâÊéí

## üö® ‰∫ã‰ª∂ÂìçÂ∫î

### ÂÆâÂÖ®‰∫ã‰ª∂ÂàÜÁ±ª

```javascript
const SecurityEventTypes = {
  LOW: {
    level: 'low',
    response: 'log',
    examples: ['failed_login', 'invalid_input']
  },
  MEDIUM: {
    level: 'medium',
    response: 'alert',
    examples: ['multiple_failed_logins', 'suspicious_activity']
  },
  HIGH: {
    level: 'high',
    response: 'block',
    examples: ['brute_force', 'sql_injection_attempt']
  },
  CRITICAL: {
    level: 'critical',
    response: 'immediate',
    examples: ['data_breach', 'system_compromise']
  }
};
```

### Ëá™Âä®ÂìçÂ∫îÁ≥ªÁªü

```javascript
// services/SecurityResponse.js
class SecurityResponse {
  async handleSecurityEvent(event) {
    const eventType = this.classifyEvent(event);
    
    switch (eventType.level) {
      case 'low':
        await this.logEvent(event);
        break;
        
      case 'medium':
        await this.logEvent(event);
        await this.sendAlert(event);
        break;
        
      case 'high':
        await this.logEvent(event);
        await this.sendAlert(event);
        await this.blockSource(event.ip);
        break;
        
      case 'critical':
        await this.logEvent(event);
        await this.sendImmediateAlert(event);
        await this.blockSource(event.ip);
        await this.notifySecurityTeam(event);
        break;
    }
  }
  
  async blockSource(ip) {
    // Ê∑ªÂä†Âà∞ÈªëÂêçÂçï
    await BlacklistedIP.create({
      ip,
      reason: 'Security violation',
      blockedAt: new Date(),
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24Â∞èÊó∂
    });
    
    // Êõ¥Êñ∞Èò≤ÁÅ´Â¢ôËßÑÂàô
    await this.updateFirewallRules(ip);
  }
}
```

## üìö ÂÆâÂÖ®ÂüπËÆ≠ÂíåÊÑèËØÜ

### ÂºÄÂèëÂõ¢ÈòüÂÆâÂÖ®ÂüπËÆ≠

1. **ÂÆâÂÖ®ÁºñÁ†ÅÂÆûË∑µ**
   - OWASP Top 10 ÊºèÊ¥û
   - ÂÆâÂÖ®‰ª£Á†ÅÂÆ°Êü•
   - Â®ÅËÉÅÂª∫Ê®°

2. **ÂÆöÊúüÂÆâÂÖ®ËØÑ‰º∞**
   - ‰ª£Á†ÅÂÆâÂÖ®Êâ´Êèè
   - Ê∏óÈÄèÊµãËØï
   - ÊºèÊ¥ûËØÑ‰º∞

3. **‰∫ã‰ª∂ÂìçÂ∫îÂüπËÆ≠**
   - ÂÆâÂÖ®‰∫ã‰ª∂ËØÜÂà´
   - ÂìçÂ∫îÊµÅÁ®ã
   - Ê≤üÈÄöÂçèËÆÆ

### Áî®Êà∑ÂÆâÂÖ®ÊïôËÇ≤

1. **ÂØÜÁ†ÅÂÆâÂÖ®**
   - Âº∫ÂØÜÁ†ÅË¶ÅÊ±Ç
   - Â§öÂõ†Á¥†ËÆ§ËØÅ
   - ÂØÜÁ†ÅÁÆ°ÁêÜÂô®‰ΩøÁî®

2. **ÈíìÈ±ºÈò≤Êä§**
   - ËØÜÂà´ÂèØÁñëÈÇÆ‰ª∂
   - È™åËØÅÈìæÊé•ÁúüÂÆûÊÄß
   - Êä•ÂëäÂèØÁñëÊ¥ªÂä®

---

**ÈáçË¶ÅÊèêÈÜí**: ÂÆâÂÖ®ÊòØ‰∏Ä‰∏™ÊåÅÁª≠ÁöÑËøáÁ®ãÔºåÈúÄË¶ÅÂÆöÊúüÂÆ°Êü•ÂíåÊõ¥Êñ∞ÂÆâÂÖ®Êé™ÊñΩ„ÄÇËØ∑Á°Æ‰øùÂõ¢Èòü‰∫ÜËß£ÊúÄÊñ∞ÁöÑÂÆâÂÖ®Â®ÅËÉÅÂíåÈò≤Êä§Êé™ÊñΩ„ÄÇ