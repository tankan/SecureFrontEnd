/**
 * 持续漏洞扫描系统
 * 实施SAST、DAST、依赖项扫描自动化
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { execSync } = require('child_process');

/**
 * 静态应用安全测试 (SAST) 扫描器
 */
class SASTScanner {
  constructor(options = {}) {
    this.config = {
      scanPaths: options.scanPaths || ['./src', './public', './'],
      excludePaths: options.excludePaths || ['node_modules', '.git', 'dist', 'build'],
      fileExtensions: options.fileExtensions || ['.js', '.jsx', '.ts', '.tsx', '.html', '.css'],
      severityLevels: ['critical', 'high', 'medium', 'low', 'info'],
      ...options
    };
    
    this.vulnerabilities = [];
    this.scanResults = new Map();
  }

  /**
   * 执行SAST扫描
   */
  async performScan() {
    console.log('🔍 开始SAST (静态应用安全测试) 扫描...');
    
    const scanResults = {
      timestamp: Date.now(),
      scannedFiles: 0,
      vulnerabilities: [],
      summary: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0
      }
    };

    // 扫描JavaScript/TypeScript文件
    await this.scanJavaScriptFiles(scanResults);
    
    // 扫描HTML文件
    await this.scanHTMLFiles(scanResults);
    
    // 扫描CSS文件
    await this.scanCSSFiles(scanResults);
    
    // 扫描配置文件
    await this.scanConfigFiles(scanResults);

    this.scanResults.set('sast', scanResults);
    return scanResults;
  }

  /**
   * 扫描JavaScript/TypeScript文件
   */
  async scanJavaScriptFiles(scanResults) {
    const jsFiles = this.findFiles(['.js', '.jsx', '.ts', '.tsx']);
    
    for (const filePath of jsFiles) {
      try {
        const content = fs.readFileSync(filePath, 'utf8');
        scanResults.scannedFiles++;
        
        // 检查常见的JavaScript安全问题
        this.checkJavaScriptVulnerabilities(filePath, content, scanResults);
        
      } catch (error) {
        console.warn(`⚠️ 无法读取文件: ${filePath}`);
      }
    }
  }

  /**
   * 检查JavaScript安全漏洞
   */
  checkJavaScriptVulnerabilities(filePath, content, scanResults) {
    const vulnerabilities = [];

    // 1. 检查eval()使用
    if (content.includes('eval(')) {
      vulnerabilities.push({
        type: 'code-injection',
        severity: 'high',
        message: '使用eval()可能导致代码注入攻击',
        line: this.findLineNumber(content, 'eval('),
        recommendation: '避免使用eval()，考虑使用JSON.parse()或其他安全替代方案'
      });
    }

    // 2. 检查innerHTML使用
    if (content.match(/\.innerHTML\s*=/)) {
      vulnerabilities.push({
        type: 'xss',
        severity: 'medium',
        message: '直接设置innerHTML可能导致XSS攻击',
        line: this.findLineNumber(content, '.innerHTML'),
        recommendation: '使用textContent或安全的DOM操作方法'
      });
    }

    // 3. 检查document.write使用
    if (content.includes('document.write')) {
      vulnerabilities.push({
        type: 'xss',
        severity: 'medium',
        message: 'document.write可能导致XSS攻击',
        line: this.findLineNumber(content, 'document.write'),
        recommendation: '使用现代DOM操作方法替代document.write'
      });
    }

    // 4. 检查硬编码密钥/密码
    const secretPatterns = [
      /password\s*[:=]\s*['"][^'"]{8,}['"]/i,
      /api[_-]?key\s*[:=]\s*['"][^'"]{16,}['"]/i,
      /secret\s*[:=]\s*['"][^'"]{16,}['"]/i,
      /token\s*[:=]\s*['"][^'"]{20,}['"]/i
    ];

    secretPatterns.forEach(pattern => {
      if (pattern.test(content)) {
        vulnerabilities.push({
          type: 'hardcoded-secrets',
          severity: 'critical',
          message: '检测到硬编码的敏感信息',
          line: this.findLineNumber(content, pattern),
          recommendation: '将敏感信息移至环境变量或安全配置文件'
        });
      }
    });

    // 5. 检查不安全的随机数生成
    if (content.includes('Math.random()')) {
      vulnerabilities.push({
        type: 'weak-randomness',
        severity: 'low',
        message: 'Math.random()不适用于安全相关的随机数生成',
        line: this.findLineNumber(content, 'Math.random()'),
        recommendation: '使用crypto.randomBytes()或crypto.getRandomValues()生成安全随机数'
      });
    }

    // 6. 检查SQL注入风险
    if (content.match(/['"`]\s*\+\s*\w+\s*\+\s*['"`]/)) {
      vulnerabilities.push({
        type: 'sql-injection',
        severity: 'high',
        message: '字符串拼接可能导致SQL注入',
        line: this.findLineNumber(content, /['"`]\s*\+\s*\w+\s*\+\s*['"`]/),
        recommendation: '使用参数化查询或ORM框架'
      });
    }

    // 7. 检查不安全的正则表达式
    const regexPatterns = content.match(/new RegExp\(['"`]([^'"`]+)['"`]\)/g);
    if (regexPatterns) {
      regexPatterns.forEach(pattern => {
        if (pattern.includes('*') || pattern.includes('+')) {
          vulnerabilities.push({
            type: 'regex-dos',
            severity: 'medium',
            message: '正则表达式可能导致ReDoS攻击',
            line: this.findLineNumber(content, pattern),
            recommendation: '优化正则表达式以避免灾难性回溯'
          });
        }
      });
    }

    // 添加漏洞到结果
    vulnerabilities.forEach(vuln => {
      const vulnerability = {
        id: crypto.randomUUID(),
        file: filePath,
        ...vuln,
        timestamp: Date.now()
      };
      
      scanResults.vulnerabilities.push(vulnerability);
      scanResults.summary[vuln.severity]++;
    });
  }

  /**
   * 扫描HTML文件
   */
  async scanHTMLFiles(scanResults) {
    const htmlFiles = this.findFiles(['.html']);
    
    for (const filePath of htmlFiles) {
      try {
        const content = fs.readFileSync(filePath, 'utf8');
        scanResults.scannedFiles++;
        
        this.checkHTMLVulnerabilities(filePath, content, scanResults);
        
      } catch (error) {
        console.warn(`⚠️ 无法读取HTML文件: ${filePath}`);
      }
    }
  }

  /**
   * 检查HTML安全漏洞
   */
  checkHTMLVulnerabilities(filePath, content, scanResults) {
    const vulnerabilities = [];

    // 1. 检查内联脚本
    if (content.match(/<script[^>]*>[\s\S]*?<\/script>/i)) {
      vulnerabilities.push({
        type: 'inline-script',
        severity: 'medium',
        message: '内联脚本可能违反CSP策略',
        line: this.findLineNumber(content, /<script[^>]*>/i),
        recommendation: '将脚本移至外部文件或使用CSP nonce'
      });
    }

    // 2. 检查内联样式
    if (content.match(/style\s*=\s*['"][^'"]*['"]/) || content.match(/<style[^>]*>[\s\S]*?<\/style>/i)) {
      vulnerabilities.push({
        type: 'inline-style',
        severity: 'low',
        message: '内联样式可能违反CSP策略',
        line: this.findLineNumber(content, /style\s*=/i),
        recommendation: '将样式移至外部CSS文件'
      });
    }

    // 3. 检查不安全的链接
    const unsafeLinks = content.match(/href\s*=\s*['"]javascript:[^'"]*['"]/gi);
    if (unsafeLinks) {
      vulnerabilities.push({
        type: 'unsafe-link',
        severity: 'high',
        message: 'javascript:协议链接可能导致XSS攻击',
        line: this.findLineNumber(content, /href\s*=\s*['"]javascript:/i),
        recommendation: '使用事件处理器替代javascript:协议'
      });
    }

    // 4. 检查缺失的安全属性
    const iframes = content.match(/<iframe[^>]*>/gi);
    if (iframes) {
      iframes.forEach(iframe => {
        if (!iframe.includes('sandbox=')) {
          vulnerabilities.push({
            type: 'missing-sandbox',
            severity: 'medium',
            message: 'iframe缺少sandbox属性',
            line: this.findLineNumber(content, iframe),
            recommendation: '为iframe添加适当的sandbox属性'
          });
        }
      });
    }

    // 添加漏洞到结果
    vulnerabilities.forEach(vuln => {
      const vulnerability = {
        id: crypto.randomUUID(),
        file: filePath,
        ...vuln,
        timestamp: Date.now()
      };
      
      scanResults.vulnerabilities.push(vulnerability);
      scanResults.summary[vuln.severity]++;
    });
  }

  /**
   * 扫描CSS文件
   */
  async scanCSSFiles(scanResults) {
    const cssFiles = this.findFiles(['.css']);
    
    for (const filePath of cssFiles) {
      try {
        const content = fs.readFileSync(filePath, 'utf8');
        scanResults.scannedFiles++;
        
        this.checkCSSVulnerabilities(filePath, content, scanResults);
        
      } catch (error) {
        console.warn(`⚠️ 无法读取CSS文件: ${filePath}`);
      }
    }
  }

  /**
   * 检查CSS安全漏洞
   */
  checkCSSVulnerabilities(filePath, content, scanResults) {
    const vulnerabilities = [];

    // 1. 检查CSS注入
    if (content.includes('expression(') || content.includes('javascript:')) {
      vulnerabilities.push({
        type: 'css-injection',
        severity: 'high',
        message: 'CSS中包含可执行代码',
        line: this.findLineNumber(content, /expression\(|javascript:/i),
        recommendation: '移除CSS中的可执行代码'
      });
    }

    // 2. 检查外部资源
    const externalUrls = content.match(/url\(['"]?https?:\/\/[^'")\s]+['"]?\)/gi);
    if (externalUrls) {
      vulnerabilities.push({
        type: 'external-resource',
        severity: 'low',
        message: 'CSS引用外部资源',
        line: this.findLineNumber(content, /url\(['"]?https?:/i),
        recommendation: '审查外部资源的安全性和必要性'
      });
    }

    // 添加漏洞到结果
    vulnerabilities.forEach(vuln => {
      const vulnerability = {
        id: crypto.randomUUID(),
        file: filePath,
        ...vuln,
        timestamp: Date.now()
      };
      
      scanResults.vulnerabilities.push(vulnerability);
      scanResults.summary[vuln.severity]++;
    });
  }

  /**
   * 扫描配置文件
   */
  async scanConfigFiles(scanResults) {
    const configFiles = this.findFiles(['.json', '.yml', '.yaml', '.env']);
    
    for (const filePath of configFiles) {
      try {
        const content = fs.readFileSync(filePath, 'utf8');
        scanResults.scannedFiles++;
        
        this.checkConfigVulnerabilities(filePath, content, scanResults);
        
      } catch (error) {
        console.warn(`⚠️ 无法读取配置文件: ${filePath}`);
      }
    }
  }

  /**
   * 检查配置文件安全问题
   */
  checkConfigVulnerabilities(filePath, content, scanResults) {
    const vulnerabilities = [];

    // 检查敏感信息泄露
    const sensitivePatterns = [
      { pattern: /password\s*[:=]\s*['"]?[^'"\s]{6,}['"]?/i, type: 'password' },
      { pattern: /api[_-]?key\s*[:=]\s*['"]?[^'"\s]{16,}['"]?/i, type: 'api-key' },
      { pattern: /secret\s*[:=]\s*['"]?[^'"\s]{16,}['"]?/i, type: 'secret' },
      { pattern: /token\s*[:=]\s*['"]?[^'"\s]{20,}['"]?/i, type: 'token' },
      { pattern: /private[_-]?key\s*[:=]/i, type: 'private-key' }
    ];

    sensitivePatterns.forEach(({ pattern, type }) => {
      if (pattern.test(content)) {
        vulnerabilities.push({
          type: 'sensitive-data-exposure',
          severity: 'critical',
          message: `配置文件中发现${type}`,
          line: this.findLineNumber(content, pattern),
          recommendation: '将敏感信息移至环境变量或安全存储'
        });
      }
    });

    // 添加漏洞到结果
    vulnerabilities.forEach(vuln => {
      const vulnerability = {
        id: crypto.randomUUID(),
        file: filePath,
        ...vuln,
        timestamp: Date.now()
      };
      
      scanResults.vulnerabilities.push(vulnerability);
      scanResults.summary[vuln.severity]++;
    });
  }

  /**
   * 查找文件
   */
  findFiles(extensions) {
    const files = [];
    
    const scanDirectory = (dir) => {
      try {
        const items = fs.readdirSync(dir);
        
        for (const item of items) {
          const fullPath = path.join(dir, item);
          const stat = fs.statSync(fullPath);
          
          if (stat.isDirectory()) {
            // 跳过排除的目录
            if (!this.config.excludePaths.some(exclude => fullPath.includes(exclude))) {
              scanDirectory(fullPath);
            }
          } else if (stat.isFile()) {
            // 检查文件扩展名
            const ext = path.extname(fullPath);
            if (extensions.includes(ext)) {
              files.push(fullPath);
            }
          }
        }
      } catch (error) {
        // 忽略无法访问的目录
      }
    };

    this.config.scanPaths.forEach(scanPath => {
      if (fs.existsSync(scanPath)) {
        scanDirectory(scanPath);
      }
    });

    return files;
  }

  /**
   * 查找行号
   */
  findLineNumber(content, pattern) {
    const lines = content.split('\n');
    for (let i = 0; i < lines.length; i++) {
      if (typeof pattern === 'string') {
        if (lines[i].includes(pattern)) {
          return i + 1;
        }
      } else if (pattern instanceof RegExp) {
        if (pattern.test(lines[i])) {
          return i + 1;
        }
      }
    }
    return 1;
  }
}

/**
 * 依赖项漏洞扫描器
 */
class DependencyScanner {
  constructor(options = {}) {
    this.config = {
      packageFiles: options.packageFiles || ['package.json', 'package-lock.json'],
      checkNpmAudit: options.checkNpmAudit !== false,
      ...options
    };
    
    this.vulnerabilities = [];
  }

  /**
   * 执行依赖项扫描
   */
  async performScan() {
    console.log('📦 开始依赖项漏洞扫描...');
    
    const scanResults = {
      timestamp: Date.now(),
      dependencies: {},
      vulnerabilities: [],
      summary: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0
      },
      recommendations: []
    };

    // 分析package.json
    await this.analyzePackageJson(scanResults);
    
    // 运行npm audit (如果可用)
    if (this.config.checkNpmAudit) {
      await this.runNpmAudit(scanResults);
    }
    
    // 检查已知的危险包
    await this.checkDangerousPackages(scanResults);

    return scanResults;
  }

  /**
   * 分析package.json
   */
  async analyzePackageJson(scanResults) {
    try {
      if (fs.existsSync('package.json')) {
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        
        scanResults.dependencies = {
          production: Object.keys(packageJson.dependencies || {}),
          development: Object.keys(packageJson.devDependencies || {}),
          total: Object.keys({
            ...packageJson.dependencies,
            ...packageJson.devDependencies
          }).length
        };

        // 检查过时的依赖项
        this.checkOutdatedDependencies(packageJson, scanResults);
        
        // 检查不安全的版本范围
        this.checkUnsafeVersionRanges(packageJson, scanResults);
      }
    } catch (error) {
      console.warn('⚠️ 无法分析package.json:', error.message);
    }
  }

  /**
   * 运行npm audit
   */
  async runNpmAudit(scanResults) {
    try {
      const auditOutput = execSync('npm audit --json', { 
        encoding: 'utf8',
        stdio: ['pipe', 'pipe', 'ignore']
      });
      
      const auditData = JSON.parse(auditOutput);
      
      if (auditData.vulnerabilities) {
        Object.entries(auditData.vulnerabilities).forEach(([packageName, vulnData]) => {
          const vulnerability = {
            id: crypto.randomUUID(),
            type: 'dependency-vulnerability',
            package: packageName,
            severity: vulnData.severity || 'medium',
            message: `${packageName}: ${vulnData.title || '已知安全漏洞'}`,
            recommendation: vulnData.url ? `查看详情: ${vulnData.url}` : '更新到安全版本',
            timestamp: Date.now()
          };
          
          scanResults.vulnerabilities.push(vulnerability);
          scanResults.summary[vulnerability.severity]++;
        });
      }
      
    } catch (error) {
      // npm audit可能不可用或返回非零退出码
      console.log('ℹ️ npm audit不可用或未发现漏洞');
    }
  }

  /**
   * 检查已知的危险包
   */
  async checkDangerousPackages(scanResults) {
    const dangerousPackages = [
      { name: 'event-stream', reason: '曾被恶意代码感染' },
      { name: 'eslint-scope', reason: '曾被恶意代码感染' },
      { name: 'getcookies', reason: '恶意包' },
      { name: 'rc', reason: '配置文件解析漏洞' },
      { name: 'lodash', versions: ['<4.17.12'], reason: '原型污染漏洞' },
      { name: 'handlebars', versions: ['<4.5.3'], reason: '模板注入漏洞' }
    ];

    try {
      if (fs.existsSync('package.json')) {
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        const allDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };

        dangerousPackages.forEach(dangerous => {
          if (allDeps[dangerous.name]) {
            const vulnerability = {
              id: crypto.randomUUID(),
              type: 'dangerous-package',
              package: dangerous.name,
              severity: 'high',
              message: `危险包 ${dangerous.name}: ${dangerous.reason}`,
              recommendation: '立即移除或更新到安全版本',
              timestamp: Date.now()
            };
            
            scanResults.vulnerabilities.push(vulnerability);
            scanResults.summary.high++;
          }
        });
      }
    } catch (error) {
      console.warn('⚠️ 检查危险包时出错:', error.message);
    }
  }

  /**
   * 检查过时的依赖项
   */
  checkOutdatedDependencies(packageJson, scanResults) {
    // 这里可以集成更复杂的版本检查逻辑
    // 目前只是一个示例实现
    
    const oldPackages = [
      { name: 'jquery', version: '2.x', reason: '版本过旧，存在安全风险' },
      { name: 'angular', version: '1.x', reason: 'AngularJS已停止维护' },
      { name: 'react', version: '<16.0.0', reason: '版本过旧，缺少安全更新' }
    ];

    const allDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };

    oldPackages.forEach(oldPkg => {
      if (allDeps[oldPkg.name]) {
        scanResults.recommendations.push({
          type: 'update-dependency',
          package: oldPkg.name,
          message: `建议更新 ${oldPkg.name}: ${oldPkg.reason}`,
          priority: 'medium'
        });
      }
    });
  }

  /**
   * 检查不安全的版本范围
   */
  checkUnsafeVersionRanges(packageJson, scanResults) {
    const allDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };

    Object.entries(allDeps).forEach(([name, version]) => {
      // 检查使用*或x的版本
      if (version.includes('*') || version.includes('x')) {
        scanResults.recommendations.push({
          type: 'fix-version-range',
          package: name,
          message: `${name}使用了不安全的版本范围: ${version}`,
          priority: 'low'
        });
      }
    });
  }
}

/**
 * 动态应用安全测试 (DAST) 扫描器
 */
class DASTScanner {
  constructor(options = {}) {
    this.config = {
      targetUrls: options.targetUrls || ['http://localhost:3000'],
      maxDepth: options.maxDepth || 3,
      timeout: options.timeout || 30000,
      ...options
    };
    
    this.vulnerabilities = [];
  }

  /**
   * 执行DAST扫描
   */
  async performScan() {
    console.log('🌐 开始DAST (动态应用安全测试) 扫描...');
    
    const scanResults = {
      timestamp: Date.now(),
      scannedUrls: [],
      vulnerabilities: [],
      summary: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0
      }
    };

    // 检查HTTP安全头
    await this.checkSecurityHeaders(scanResults);
    
    // 检查SSL/TLS配置
    await this.checkSSLConfiguration(scanResults);
    
    // 检查常见的Web漏洞
    await this.checkCommonVulnerabilities(scanResults);

    return scanResults;
  }

  /**
   * 检查HTTP安全头
   */
  async checkSecurityHeaders(scanResults) {
    const requiredHeaders = [
      'Content-Security-Policy',
      'Strict-Transport-Security',
      'X-Frame-Options',
      'X-Content-Type-Options',
      'Referrer-Policy'
    ];

    // 模拟HTTP头检查 (实际实现需要HTTP客户端)
    const missingHeaders = ['Strict-Transport-Security', 'Content-Security-Policy'];
    
    missingHeaders.forEach(header => {
      const vulnerability = {
        id: crypto.randomUUID(),
        type: 'missing-security-header',
        severity: 'medium',
        message: `缺少安全头: ${header}`,
        recommendation: `配置${header}安全头`,
        timestamp: Date.now()
      };
      
      scanResults.vulnerabilities.push(vulnerability);
      scanResults.summary.medium++;
    });
  }

  /**
   * 检查SSL/TLS配置
   */
  async checkSSLConfiguration(scanResults) {
    // 模拟SSL检查
    const sslIssues = [
      {
        type: 'weak-cipher',
        severity: 'high',
        message: '使用了弱加密套件',
        recommendation: '配置强加密套件，禁用弱加密算法'
      },
      {
        type: 'certificate-issue',
        severity: 'medium',
        message: 'SSL证书即将过期',
        recommendation: '及时更新SSL证书'
      }
    ];

    // 这里只是示例，实际需要真实的SSL检查
    // sslIssues.forEach(issue => {
    //   const vulnerability = {
    //     id: crypto.randomUUID(),
    //     ...issue,
    //     timestamp: Date.now()
    //   };
      
    //   scanResults.vulnerabilities.push(vulnerability);
    //   scanResults.summary[issue.severity]++;
    // });
  }

  /**
   * 检查常见Web漏洞
   */
  async checkCommonVulnerabilities(scanResults) {
    // 模拟常见漏洞检查
    const commonVulns = [
      {
        type: 'clickjacking',
        severity: 'medium',
        message: '可能存在点击劫持风险',
        recommendation: '配置X-Frame-Options或CSP frame-ancestors'
      },
      {
        type: 'information-disclosure',
        severity: 'low',
        message: '服务器信息泄露',
        recommendation: '隐藏服务器版本信息'
      }
    ];

    // 添加一些示例漏洞
    commonVulns.slice(0, 1).forEach(vuln => {
      const vulnerability = {
        id: crypto.randomUUID(),
        ...vuln,
        timestamp: Date.now()
      };
      
      scanResults.vulnerabilities.push(vulnerability);
      scanResults.summary[vuln.severity]++;
    });
  }
}

/**
 * 综合漏洞扫描管理器
 */
class VulnerabilityScanner {
  constructor(options = {}) {
    this.sastScanner = new SASTScanner(options.sast);
    this.dependencyScanner = new DependencyScanner(options.dependency);
    this.dastScanner = new DASTScanner(options.dast);
    
    this.config = {
      enableSAST: options.enableSAST !== false,
      enableDependencyScanning: options.enableDependencyScanning !== false,
      enableDAST: options.enableDAST !== false,
      ...options
    };
  }

  /**
   * 执行完整的漏洞扫描
   */
  async performComprehensiveScan() {
    console.log('🔒 开始综合漏洞扫描...');
    console.log('=' .repeat(50));
    
    const results = {
      timestamp: Date.now(),
      scanTypes: [],
      totalVulnerabilities: 0,
      summary: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0
      },
      scans: {},
      recommendations: [],
      securityScore: 0
    };

    try {
      // SAST扫描
      if (this.config.enableSAST) {
        console.log('\n📝 执行SAST扫描...');
        results.scans.sast = await this.sastScanner.performScan();
        results.scanTypes.push('SAST');
        this.aggregateResults(results, results.scans.sast);
      }

      // 依赖项扫描
      if (this.config.enableDependencyScanning) {
        console.log('\n📦 执行依赖项扫描...');
        results.scans.dependency = await this.dependencyScanner.performScan();
        results.scanTypes.push('Dependency');
        this.aggregateResults(results, results.scans.dependency);
      }

      // DAST扫描
      if (this.config.enableDAST) {
        console.log('\n🌐 执行DAST扫描...');
        results.scans.dast = await this.dastScanner.performScan();
        results.scanTypes.push('DAST');
        this.aggregateResults(results, results.scans.dast);
      }

      // 生成综合建议
      results.recommendations = this.generateRecommendations(results);
      
      // 计算安全评分
      results.securityScore = this.calculateSecurityScore(results);

      return results;

    } catch (error) {
      console.error('❌ 扫描过程中发生错误:', error);
      throw error;
    }
  }

  /**
   * 聚合扫描结果
   */
  aggregateResults(mainResults, scanResults) {
    if (scanResults.vulnerabilities) {
      mainResults.totalVulnerabilities += scanResults.vulnerabilities.length;
      
      // 聚合严重程度统计
      Object.keys(mainResults.summary).forEach(severity => {
        mainResults.summary[severity] += scanResults.summary[severity] || 0;
      });
    }
  }

  /**
   * 生成综合建议
   */
  generateRecommendations(results) {
    const recommendations = [];

    // 基于漏洞数量的建议
    if (results.summary.critical > 0) {
      recommendations.push({
        priority: 'critical',
        message: `发现${results.summary.critical}个严重漏洞，需要立即修复`,
        action: '优先修复所有严重级别的安全漏洞'
      });
    }

    if (results.summary.high > 5) {
      recommendations.push({
        priority: 'high',
        message: `发现${results.summary.high}个高危漏洞`,
        action: '制定修复计划，尽快解决高危漏洞'
      });
    }

    // 基于扫描类型的建议
    if (results.scans.sast && results.scans.sast.vulnerabilities.length > 0) {
      recommendations.push({
        priority: 'medium',
        message: '代码中存在安全问题',
        action: '审查代码，实施安全编码最佳实践'
      });
    }

    if (results.scans.dependency && results.scans.dependency.vulnerabilities.length > 0) {
      recommendations.push({
        priority: 'medium',
        message: '依赖项存在已知漏洞',
        action: '更新依赖项到安全版本'
      });
    }

    // 通用安全建议
    if (results.securityScore < 80) {
      recommendations.push({
        priority: 'medium',
        message: '整体安全评分较低',
        action: '实施全面的安全加固措施'
      });
    }

    return recommendations;
  }

  /**
   * 计算安全评分
   */
  calculateSecurityScore(results) {
    let score = 100;

    // 根据漏洞严重程度扣分
    score -= results.summary.critical * 20;
    score -= results.summary.high * 10;
    score -= results.summary.medium * 5;
    score -= results.summary.low * 2;
    score -= results.summary.info * 1;

    // 确保分数不低于0
    return Math.max(0, score);
  }

  /**
   * 生成扫描报告
   */
  generateReport(results) {
    const report = {
      ...results,
      generatedAt: new Date().toISOString(),
      scanDuration: Date.now() - results.timestamp,
      riskLevel: this.calculateRiskLevel(results),
      nextScanRecommended: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString() // 7天后
    };

    return report;
  }

  /**
   * 计算风险等级
   */
  calculateRiskLevel(results) {
    if (results.summary.critical > 0) return 'Critical';
    if (results.summary.high > 3) return 'High';
    if (results.summary.medium > 5) return 'Medium';
    return 'Low';
  }
}

module.exports = {
  VulnerabilityScanner,
  SASTScanner,
  DependencyScanner,
  DASTScanner
};