/**
 * æŒç»­æ¼æ´æ‰«æç³»ç»Ÿ
 * å®æ–½SASTã€DASTã€ä¾èµ–é¡¹æ‰«æè‡ªåŠ¨åŒ–
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { execSync } = require('child_process');

/**
 * é™æ€åº”ç”¨å®‰å…¨æµ‹è¯• (SAST) æ‰«æå™¨
 */
class SASTScanner {
  constructor(options = {}) {
    this.config = {
      scanPaths: options.scanPaths || ['./src', './public', './'],
      excludePaths: options.excludePaths || ['node_modules', '.git', 'dist', 'build'],
      fileExtensions: options.fileExtensions || ['.js', '.jsx', '.ts', '.tsx', '.html', '.css'],
      severityLevels: ['critical', 'high', 'medium', 'low', 'info'],
      ...options
    };
    
    this.vulnerabilities = [];
    this.scanResults = new Map();
  }

  /**
   * æ‰§è¡ŒSASTæ‰«æ
   */
  async performScan() {
    console.log('ğŸ” å¼€å§‹SAST (é™æ€åº”ç”¨å®‰å…¨æµ‹è¯•) æ‰«æ...');
    
    const scanResults = {
      timestamp: Date.now(),
      scannedFiles: 0,
      vulnerabilities: [],
      summary: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0
      }
    };

    // æ‰«æJavaScript/TypeScriptæ–‡ä»¶
    await this.scanJavaScriptFiles(scanResults);
    
    // æ‰«æHTMLæ–‡ä»¶
    await this.scanHTMLFiles(scanResults);
    
    // æ‰«æCSSæ–‡ä»¶
    await this.scanCSSFiles(scanResults);
    
    // æ‰«æé…ç½®æ–‡ä»¶
    await this.scanConfigFiles(scanResults);

    this.scanResults.set('sast', scanResults);
    return scanResults;
  }

  /**
   * æ‰«æJavaScript/TypeScriptæ–‡ä»¶
   */
  async scanJavaScriptFiles(scanResults) {
    const jsFiles = this.findFiles(['.js', '.jsx', '.ts', '.tsx']);
    
    for (const filePath of jsFiles) {
      try {
        const content = fs.readFileSync(filePath, 'utf8');
        scanResults.scannedFiles++;
        
        // æ£€æŸ¥å¸¸è§çš„JavaScriptå®‰å…¨é—®é¢˜
        this.checkJavaScriptVulnerabilities(filePath, content, scanResults);
        
      } catch (error) {
        console.warn(`âš ï¸ æ— æ³•è¯»å–æ–‡ä»¶: ${filePath}`);
      }
    }
  }

  /**
   * æ£€æŸ¥JavaScriptå®‰å…¨æ¼æ´
   */
  checkJavaScriptVulnerabilities(filePath, content, scanResults) {
    const vulnerabilities = [];

    // 1. æ£€æŸ¥eval()ä½¿ç”¨
    if (content.includes('eval(')) {
      vulnerabilities.push({
        type: 'code-injection',
        severity: 'high',
        message: 'ä½¿ç”¨eval()å¯èƒ½å¯¼è‡´ä»£ç æ³¨å…¥æ”»å‡»',
        line: this.findLineNumber(content, 'eval('),
        recommendation: 'é¿å…ä½¿ç”¨eval()ï¼Œè€ƒè™‘ä½¿ç”¨JSON.parse()æˆ–å…¶ä»–å®‰å…¨æ›¿ä»£æ–¹æ¡ˆ'
      });
    }

    // 2. æ£€æŸ¥innerHTMLä½¿ç”¨
    if (content.match(/\.innerHTML\s*=/)) {
      vulnerabilities.push({
        type: 'xss',
        severity: 'medium',
        message: 'ç›´æ¥è®¾ç½®innerHTMLå¯èƒ½å¯¼è‡´XSSæ”»å‡»',
        line: this.findLineNumber(content, '.innerHTML'),
        recommendation: 'ä½¿ç”¨textContentæˆ–å®‰å…¨çš„DOMæ“ä½œæ–¹æ³•'
      });
    }

    // 3. æ£€æŸ¥document.writeä½¿ç”¨
    if (content.includes('document.write')) {
      vulnerabilities.push({
        type: 'xss',
        severity: 'medium',
        message: 'document.writeå¯èƒ½å¯¼è‡´XSSæ”»å‡»',
        line: this.findLineNumber(content, 'document.write'),
        recommendation: 'ä½¿ç”¨ç°ä»£DOMæ“ä½œæ–¹æ³•æ›¿ä»£document.write'
      });
    }

    // 4. æ£€æŸ¥ç¡¬ç¼–ç å¯†é’¥/å¯†ç 
    const secretPatterns = [
      /password\s*[:=]\s*['"][^'"]{8,}['"]/i,
      /api[_-]?key\s*[:=]\s*['"][^'"]{16,}['"]/i,
      /secret\s*[:=]\s*['"][^'"]{16,}['"]/i,
      /token\s*[:=]\s*['"][^'"]{20,}['"]/i
    ];

    secretPatterns.forEach(pattern => {
      if (pattern.test(content)) {
        vulnerabilities.push({
          type: 'hardcoded-secrets',
          severity: 'critical',
          message: 'æ£€æµ‹åˆ°ç¡¬ç¼–ç çš„æ•æ„Ÿä¿¡æ¯',
          line: this.findLineNumber(content, pattern),
          recommendation: 'å°†æ•æ„Ÿä¿¡æ¯ç§»è‡³ç¯å¢ƒå˜é‡æˆ–å®‰å…¨é…ç½®æ–‡ä»¶'
        });
      }
    });

    // 5. æ£€æŸ¥ä¸å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆ
    if (content.includes('Math.random()')) {
      vulnerabilities.push({
        type: 'weak-randomness',
        severity: 'low',
        message: 'Math.random()ä¸é€‚ç”¨äºå®‰å…¨ç›¸å…³çš„éšæœºæ•°ç”Ÿæˆ',
        line: this.findLineNumber(content, 'Math.random()'),
        recommendation: 'ä½¿ç”¨crypto.randomBytes()æˆ–crypto.getRandomValues()ç”Ÿæˆå®‰å…¨éšæœºæ•°'
      });
    }

    // 6. æ£€æŸ¥SQLæ³¨å…¥é£é™©
    if (content.match(/['"`]\s*\+\s*\w+\s*\+\s*['"`]/)) {
      vulnerabilities.push({
        type: 'sql-injection',
        severity: 'high',
        message: 'å­—ç¬¦ä¸²æ‹¼æ¥å¯èƒ½å¯¼è‡´SQLæ³¨å…¥',
        line: this.findLineNumber(content, /['"`]\s*\+\s*\w+\s*\+\s*['"`]/),
        recommendation: 'ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢æˆ–ORMæ¡†æ¶'
      });
    }

    // 7. æ£€æŸ¥ä¸å®‰å…¨çš„æ­£åˆ™è¡¨è¾¾å¼
    const regexPatterns = content.match(/new RegExp\(['"`]([^'"`]+)['"`]\)/g);
    if (regexPatterns) {
      regexPatterns.forEach(pattern => {
        if (pattern.includes('*') || pattern.includes('+')) {
          vulnerabilities.push({
            type: 'regex-dos',
            severity: 'medium',
            message: 'æ­£åˆ™è¡¨è¾¾å¼å¯èƒ½å¯¼è‡´ReDoSæ”»å‡»',
            line: this.findLineNumber(content, pattern),
            recommendation: 'ä¼˜åŒ–æ­£åˆ™è¡¨è¾¾å¼ä»¥é¿å…ç¾éš¾æ€§å›æº¯'
          });
        }
      });
    }

    // æ·»åŠ æ¼æ´åˆ°ç»“æœ
    vulnerabilities.forEach(vuln => {
      const vulnerability = {
        id: crypto.randomUUID(),
        file: filePath,
        ...vuln,
        timestamp: Date.now()
      };
      
      scanResults.vulnerabilities.push(vulnerability);
      scanResults.summary[vuln.severity]++;
    });
  }

  /**
   * æ‰«æHTMLæ–‡ä»¶
   */
  async scanHTMLFiles(scanResults) {
    const htmlFiles = this.findFiles(['.html']);
    
    for (const filePath of htmlFiles) {
      try {
        const content = fs.readFileSync(filePath, 'utf8');
        scanResults.scannedFiles++;
        
        this.checkHTMLVulnerabilities(filePath, content, scanResults);
        
      } catch (error) {
        console.warn(`âš ï¸ æ— æ³•è¯»å–HTMLæ–‡ä»¶: ${filePath}`);
      }
    }
  }

  /**
   * æ£€æŸ¥HTMLå®‰å…¨æ¼æ´
   */
  checkHTMLVulnerabilities(filePath, content, scanResults) {
    const vulnerabilities = [];

    // 1. æ£€æŸ¥å†…è”è„šæœ¬
    if (content.match(/<script[^>]*>[\s\S]*?<\/script>/i)) {
      vulnerabilities.push({
        type: 'inline-script',
        severity: 'medium',
        message: 'å†…è”è„šæœ¬å¯èƒ½è¿åCSPç­–ç•¥',
        line: this.findLineNumber(content, /<script[^>]*>/i),
        recommendation: 'å°†è„šæœ¬ç§»è‡³å¤–éƒ¨æ–‡ä»¶æˆ–ä½¿ç”¨CSP nonce'
      });
    }

    // 2. æ£€æŸ¥å†…è”æ ·å¼
    if (content.match(/style\s*=\s*['"][^'"]*['"]/) || content.match(/<style[^>]*>[\s\S]*?<\/style>/i)) {
      vulnerabilities.push({
        type: 'inline-style',
        severity: 'low',
        message: 'å†…è”æ ·å¼å¯èƒ½è¿åCSPç­–ç•¥',
        line: this.findLineNumber(content, /style\s*=/i),
        recommendation: 'å°†æ ·å¼ç§»è‡³å¤–éƒ¨CSSæ–‡ä»¶'
      });
    }

    // 3. æ£€æŸ¥ä¸å®‰å…¨çš„é“¾æ¥
    const unsafeLinks = content.match(/href\s*=\s*['"]javascript:[^'"]*['"]/gi);
    if (unsafeLinks) {
      vulnerabilities.push({
        type: 'unsafe-link',
        severity: 'high',
        message: 'javascript:åè®®é“¾æ¥å¯èƒ½å¯¼è‡´XSSæ”»å‡»',
        line: this.findLineNumber(content, /href\s*=\s*['"]javascript:/i),
        recommendation: 'ä½¿ç”¨äº‹ä»¶å¤„ç†å™¨æ›¿ä»£javascript:åè®®'
      });
    }

    // 4. æ£€æŸ¥ç¼ºå¤±çš„å®‰å…¨å±æ€§
    const iframes = content.match(/<iframe[^>]*>/gi);
    if (iframes) {
      iframes.forEach(iframe => {
        if (!iframe.includes('sandbox=')) {
          vulnerabilities.push({
            type: 'missing-sandbox',
            severity: 'medium',
            message: 'iframeç¼ºå°‘sandboxå±æ€§',
            line: this.findLineNumber(content, iframe),
            recommendation: 'ä¸ºiframeæ·»åŠ é€‚å½“çš„sandboxå±æ€§'
          });
        }
      });
    }

    // æ·»åŠ æ¼æ´åˆ°ç»“æœ
    vulnerabilities.forEach(vuln => {
      const vulnerability = {
        id: crypto.randomUUID(),
        file: filePath,
        ...vuln,
        timestamp: Date.now()
      };
      
      scanResults.vulnerabilities.push(vulnerability);
      scanResults.summary[vuln.severity]++;
    });
  }

  /**
   * æ‰«æCSSæ–‡ä»¶
   */
  async scanCSSFiles(scanResults) {
    const cssFiles = this.findFiles(['.css']);
    
    for (const filePath of cssFiles) {
      try {
        const content = fs.readFileSync(filePath, 'utf8');
        scanResults.scannedFiles++;
        
        this.checkCSSVulnerabilities(filePath, content, scanResults);
        
      } catch (error) {
        console.warn(`âš ï¸ æ— æ³•è¯»å–CSSæ–‡ä»¶: ${filePath}`);
      }
    }
  }

  /**
   * æ£€æŸ¥CSSå®‰å…¨æ¼æ´
   */
  checkCSSVulnerabilities(filePath, content, scanResults) {
    const vulnerabilities = [];

    // 1. æ£€æŸ¥CSSæ³¨å…¥
    if (content.includes('expression(') || content.includes('javascript:')) {
      vulnerabilities.push({
        type: 'css-injection',
        severity: 'high',
        message: 'CSSä¸­åŒ…å«å¯æ‰§è¡Œä»£ç ',
        line: this.findLineNumber(content, /expression\(|javascript:/i),
        recommendation: 'ç§»é™¤CSSä¸­çš„å¯æ‰§è¡Œä»£ç '
      });
    }

    // 2. æ£€æŸ¥å¤–éƒ¨èµ„æº
    const externalUrls = content.match(/url\(['"]?https?:\/\/[^'")\s]+['"]?\)/gi);
    if (externalUrls) {
      vulnerabilities.push({
        type: 'external-resource',
        severity: 'low',
        message: 'CSSå¼•ç”¨å¤–éƒ¨èµ„æº',
        line: this.findLineNumber(content, /url\(['"]?https?:/i),
        recommendation: 'å®¡æŸ¥å¤–éƒ¨èµ„æºçš„å®‰å…¨æ€§å’Œå¿…è¦æ€§'
      });
    }

    // æ·»åŠ æ¼æ´åˆ°ç»“æœ
    vulnerabilities.forEach(vuln => {
      const vulnerability = {
        id: crypto.randomUUID(),
        file: filePath,
        ...vuln,
        timestamp: Date.now()
      };
      
      scanResults.vulnerabilities.push(vulnerability);
      scanResults.summary[vuln.severity]++;
    });
  }

  /**
   * æ‰«æé…ç½®æ–‡ä»¶
   */
  async scanConfigFiles(scanResults) {
    const configFiles = this.findFiles(['.json', '.yml', '.yaml', '.env']);
    
    for (const filePath of configFiles) {
      try {
        const content = fs.readFileSync(filePath, 'utf8');
        scanResults.scannedFiles++;
        
        this.checkConfigVulnerabilities(filePath, content, scanResults);
        
      } catch (error) {
        console.warn(`âš ï¸ æ— æ³•è¯»å–é…ç½®æ–‡ä»¶: ${filePath}`);
      }
    }
  }

  /**
   * æ£€æŸ¥é…ç½®æ–‡ä»¶å®‰å…¨é—®é¢˜
   */
  checkConfigVulnerabilities(filePath, content, scanResults) {
    const vulnerabilities = [];

    // æ£€æŸ¥æ•æ„Ÿä¿¡æ¯æ³„éœ²
    const sensitivePatterns = [
      { pattern: /password\s*[:=]\s*['"]?[^'"\s]{6,}['"]?/i, type: 'password' },
      { pattern: /api[_-]?key\s*[:=]\s*['"]?[^'"\s]{16,}['"]?/i, type: 'api-key' },
      { pattern: /secret\s*[:=]\s*['"]?[^'"\s]{16,}['"]?/i, type: 'secret' },
      { pattern: /token\s*[:=]\s*['"]?[^'"\s]{20,}['"]?/i, type: 'token' },
      { pattern: /private[_-]?key\s*[:=]/i, type: 'private-key' }
    ];

    sensitivePatterns.forEach(({ pattern, type }) => {
      if (pattern.test(content)) {
        vulnerabilities.push({
          type: 'sensitive-data-exposure',
          severity: 'critical',
          message: `é…ç½®æ–‡ä»¶ä¸­å‘ç°${type}`,
          line: this.findLineNumber(content, pattern),
          recommendation: 'å°†æ•æ„Ÿä¿¡æ¯ç§»è‡³ç¯å¢ƒå˜é‡æˆ–å®‰å…¨å­˜å‚¨'
        });
      }
    });

    // æ·»åŠ æ¼æ´åˆ°ç»“æœ
    vulnerabilities.forEach(vuln => {
      const vulnerability = {
        id: crypto.randomUUID(),
        file: filePath,
        ...vuln,
        timestamp: Date.now()
      };
      
      scanResults.vulnerabilities.push(vulnerability);
      scanResults.summary[vuln.severity]++;
    });
  }

  /**
   * æŸ¥æ‰¾æ–‡ä»¶
   */
  findFiles(extensions) {
    const files = [];
    
    const scanDirectory = (dir) => {
      try {
        const items = fs.readdirSync(dir);
        
        for (const item of items) {
          const fullPath = path.join(dir, item);
          const stat = fs.statSync(fullPath);
          
          if (stat.isDirectory()) {
            // è·³è¿‡æ’é™¤çš„ç›®å½•
            if (!this.config.excludePaths.some(exclude => fullPath.includes(exclude))) {
              scanDirectory(fullPath);
            }
          } else if (stat.isFile()) {
            // æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
            const ext = path.extname(fullPath);
            if (extensions.includes(ext)) {
              files.push(fullPath);
            }
          }
        }
      } catch (error) {
        // å¿½ç•¥æ— æ³•è®¿é—®çš„ç›®å½•
      }
    };

    this.config.scanPaths.forEach(scanPath => {
      if (fs.existsSync(scanPath)) {
        scanDirectory(scanPath);
      }
    });

    return files;
  }

  /**
   * æŸ¥æ‰¾è¡Œå·
   */
  findLineNumber(content, pattern) {
    const lines = content.split('\n');
    for (let i = 0; i < lines.length; i++) {
      if (typeof pattern === 'string') {
        if (lines[i].includes(pattern)) {
          return i + 1;
        }
      } else if (pattern instanceof RegExp) {
        if (pattern.test(lines[i])) {
          return i + 1;
        }
      }
    }
    return 1;
  }
}

/**
 * ä¾èµ–é¡¹æ¼æ´æ‰«æå™¨
 */
class DependencyScanner {
  constructor(options = {}) {
    this.config = {
      packageFiles: options.packageFiles || ['package.json', 'package-lock.json'],
      checkNpmAudit: options.checkNpmAudit !== false,
      ...options
    };
    
    this.vulnerabilities = [];
  }

  /**
   * æ‰§è¡Œä¾èµ–é¡¹æ‰«æ
   */
  async performScan() {
    console.log('ğŸ“¦ å¼€å§‹ä¾èµ–é¡¹æ¼æ´æ‰«æ...');
    
    const scanResults = {
      timestamp: Date.now(),
      dependencies: {},
      vulnerabilities: [],
      summary: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0
      },
      recommendations: []
    };

    // åˆ†æpackage.json
    await this.analyzePackageJson(scanResults);
    
    // è¿è¡Œnpm audit (å¦‚æœå¯ç”¨)
    if (this.config.checkNpmAudit) {
      await this.runNpmAudit(scanResults);
    }
    
    // æ£€æŸ¥å·²çŸ¥çš„å±é™©åŒ…
    await this.checkDangerousPackages(scanResults);

    return scanResults;
  }

  /**
   * åˆ†æpackage.json
   */
  async analyzePackageJson(scanResults) {
    try {
      if (fs.existsSync('package.json')) {
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        
        scanResults.dependencies = {
          production: Object.keys(packageJson.dependencies || {}),
          development: Object.keys(packageJson.devDependencies || {}),
          total: Object.keys({
            ...packageJson.dependencies,
            ...packageJson.devDependencies
          }).length
        };

        // æ£€æŸ¥è¿‡æ—¶çš„ä¾èµ–é¡¹
        this.checkOutdatedDependencies(packageJson, scanResults);
        
        // æ£€æŸ¥ä¸å®‰å…¨çš„ç‰ˆæœ¬èŒƒå›´
        this.checkUnsafeVersionRanges(packageJson, scanResults);
      }
    } catch (error) {
      console.warn('âš ï¸ æ— æ³•åˆ†æpackage.json:', error.message);
    }
  }

  /**
   * è¿è¡Œnpm audit
   */
  async runNpmAudit(scanResults) {
    try {
      const auditOutput = execSync('npm audit --json', { 
        encoding: 'utf8',
        stdio: ['pipe', 'pipe', 'ignore']
      });
      
      const auditData = JSON.parse(auditOutput);
      
      if (auditData.vulnerabilities) {
        Object.entries(auditData.vulnerabilities).forEach(([packageName, vulnData]) => {
          const vulnerability = {
            id: crypto.randomUUID(),
            type: 'dependency-vulnerability',
            package: packageName,
            severity: vulnData.severity || 'medium',
            message: `${packageName}: ${vulnData.title || 'å·²çŸ¥å®‰å…¨æ¼æ´'}`,
            recommendation: vulnData.url ? `æŸ¥çœ‹è¯¦æƒ…: ${vulnData.url}` : 'æ›´æ–°åˆ°å®‰å…¨ç‰ˆæœ¬',
            timestamp: Date.now()
          };
          
          scanResults.vulnerabilities.push(vulnerability);
          scanResults.summary[vulnerability.severity]++;
        });
      }
      
    } catch (error) {
      // npm auditå¯èƒ½ä¸å¯ç”¨æˆ–è¿”å›éé›¶é€€å‡ºç 
      console.log('â„¹ï¸ npm auditä¸å¯ç”¨æˆ–æœªå‘ç°æ¼æ´');
    }
  }

  /**
   * æ£€æŸ¥å·²çŸ¥çš„å±é™©åŒ…
   */
  async checkDangerousPackages(scanResults) {
    const dangerousPackages = [
      { name: 'event-stream', reason: 'æ›¾è¢«æ¶æ„ä»£ç æ„ŸæŸ“' },
      { name: 'eslint-scope', reason: 'æ›¾è¢«æ¶æ„ä»£ç æ„ŸæŸ“' },
      { name: 'getcookies', reason: 'æ¶æ„åŒ…' },
      { name: 'rc', reason: 'é…ç½®æ–‡ä»¶è§£ææ¼æ´' },
      { name: 'lodash', versions: ['<4.17.12'], reason: 'åŸå‹æ±¡æŸ“æ¼æ´' },
      { name: 'handlebars', versions: ['<4.5.3'], reason: 'æ¨¡æ¿æ³¨å…¥æ¼æ´' }
    ];

    try {
      if (fs.existsSync('package.json')) {
        const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
        const allDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };

        dangerousPackages.forEach(dangerous => {
          if (allDeps[dangerous.name]) {
            const vulnerability = {
              id: crypto.randomUUID(),
              type: 'dangerous-package',
              package: dangerous.name,
              severity: 'high',
              message: `å±é™©åŒ… ${dangerous.name}: ${dangerous.reason}`,
              recommendation: 'ç«‹å³ç§»é™¤æˆ–æ›´æ–°åˆ°å®‰å…¨ç‰ˆæœ¬',
              timestamp: Date.now()
            };
            
            scanResults.vulnerabilities.push(vulnerability);
            scanResults.summary.high++;
          }
        });
      }
    } catch (error) {
      console.warn('âš ï¸ æ£€æŸ¥å±é™©åŒ…æ—¶å‡ºé”™:', error.message);
    }
  }

  /**
   * æ£€æŸ¥è¿‡æ—¶çš„ä¾èµ–é¡¹
   */
  checkOutdatedDependencies(packageJson, scanResults) {
    // è¿™é‡Œå¯ä»¥é›†æˆæ›´å¤æ‚çš„ç‰ˆæœ¬æ£€æŸ¥é€»è¾‘
    // ç›®å‰åªæ˜¯ä¸€ä¸ªç¤ºä¾‹å®ç°
    
    const oldPackages = [
      { name: 'jquery', version: '2.x', reason: 'ç‰ˆæœ¬è¿‡æ—§ï¼Œå­˜åœ¨å®‰å…¨é£é™©' },
      { name: 'angular', version: '1.x', reason: 'AngularJSå·²åœæ­¢ç»´æŠ¤' },
      { name: 'react', version: '<16.0.0', reason: 'ç‰ˆæœ¬è¿‡æ—§ï¼Œç¼ºå°‘å®‰å…¨æ›´æ–°' }
    ];

    const allDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };

    oldPackages.forEach(oldPkg => {
      if (allDeps[oldPkg.name]) {
        scanResults.recommendations.push({
          type: 'update-dependency',
          package: oldPkg.name,
          message: `å»ºè®®æ›´æ–° ${oldPkg.name}: ${oldPkg.reason}`,
          priority: 'medium'
        });
      }
    });
  }

  /**
   * æ£€æŸ¥ä¸å®‰å…¨çš„ç‰ˆæœ¬èŒƒå›´
   */
  checkUnsafeVersionRanges(packageJson, scanResults) {
    const allDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };

    Object.entries(allDeps).forEach(([name, version]) => {
      // æ£€æŸ¥ä½¿ç”¨*æˆ–xçš„ç‰ˆæœ¬
      if (version.includes('*') || version.includes('x')) {
        scanResults.recommendations.push({
          type: 'fix-version-range',
          package: name,
          message: `${name}ä½¿ç”¨äº†ä¸å®‰å…¨çš„ç‰ˆæœ¬èŒƒå›´: ${version}`,
          priority: 'low'
        });
      }
    });
  }
}

/**
 * åŠ¨æ€åº”ç”¨å®‰å…¨æµ‹è¯• (DAST) æ‰«æå™¨
 */
class DASTScanner {
  constructor(options = {}) {
    this.config = {
      targetUrls: options.targetUrls || ['http://localhost:3000'],
      maxDepth: options.maxDepth || 3,
      timeout: options.timeout || 30000,
      ...options
    };
    
    this.vulnerabilities = [];
  }

  /**
   * æ‰§è¡ŒDASTæ‰«æ
   */
  async performScan() {
    console.log('ğŸŒ å¼€å§‹DAST (åŠ¨æ€åº”ç”¨å®‰å…¨æµ‹è¯•) æ‰«æ...');
    
    const scanResults = {
      timestamp: Date.now(),
      scannedUrls: [],
      vulnerabilities: [],
      summary: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0
      }
    };

    // æ£€æŸ¥HTTPå®‰å…¨å¤´
    await this.checkSecurityHeaders(scanResults);
    
    // æ£€æŸ¥SSL/TLSé…ç½®
    await this.checkSSLConfiguration(scanResults);
    
    // æ£€æŸ¥å¸¸è§çš„Webæ¼æ´
    await this.checkCommonVulnerabilities(scanResults);

    return scanResults;
  }

  /**
   * æ£€æŸ¥HTTPå®‰å…¨å¤´
   */
  async checkSecurityHeaders(scanResults) {
    const requiredHeaders = [
      'Content-Security-Policy',
      'Strict-Transport-Security',
      'X-Frame-Options',
      'X-Content-Type-Options',
      'Referrer-Policy'
    ];

    // æ¨¡æ‹ŸHTTPå¤´æ£€æŸ¥ (å®é™…å®ç°éœ€è¦HTTPå®¢æˆ·ç«¯)
    const missingHeaders = ['Strict-Transport-Security', 'Content-Security-Policy'];
    
    missingHeaders.forEach(header => {
      const vulnerability = {
        id: crypto.randomUUID(),
        type: 'missing-security-header',
        severity: 'medium',
        message: `ç¼ºå°‘å®‰å…¨å¤´: ${header}`,
        recommendation: `é…ç½®${header}å®‰å…¨å¤´`,
        timestamp: Date.now()
      };
      
      scanResults.vulnerabilities.push(vulnerability);
      scanResults.summary.medium++;
    });
  }

  /**
   * æ£€æŸ¥SSL/TLSé…ç½®
   */
  async checkSSLConfiguration(scanResults) {
    // æ¨¡æ‹ŸSSLæ£€æŸ¥
    const sslIssues = [
      {
        type: 'weak-cipher',
        severity: 'high',
        message: 'ä½¿ç”¨äº†å¼±åŠ å¯†å¥—ä»¶',
        recommendation: 'é…ç½®å¼ºåŠ å¯†å¥—ä»¶ï¼Œç¦ç”¨å¼±åŠ å¯†ç®—æ³•'
      },
      {
        type: 'certificate-issue',
        severity: 'medium',
        message: 'SSLè¯ä¹¦å³å°†è¿‡æœŸ',
        recommendation: 'åŠæ—¶æ›´æ–°SSLè¯ä¹¦'
      }
    ];

    // è¿™é‡Œåªæ˜¯ç¤ºä¾‹ï¼Œå®é™…éœ€è¦çœŸå®çš„SSLæ£€æŸ¥
    // sslIssues.forEach(issue => {
    //   const vulnerability = {
    //     id: crypto.randomUUID(),
    //     ...issue,
    //     timestamp: Date.now()
    //   };
      
    //   scanResults.vulnerabilities.push(vulnerability);
    //   scanResults.summary[issue.severity]++;
    // });
  }

  /**
   * æ£€æŸ¥å¸¸è§Webæ¼æ´
   */
  async checkCommonVulnerabilities(scanResults) {
    // æ¨¡æ‹Ÿå¸¸è§æ¼æ´æ£€æŸ¥
    const commonVulns = [
      {
        type: 'clickjacking',
        severity: 'medium',
        message: 'å¯èƒ½å­˜åœ¨ç‚¹å‡»åŠ«æŒé£é™©',
        recommendation: 'é…ç½®X-Frame-Optionsæˆ–CSP frame-ancestors'
      },
      {
        type: 'information-disclosure',
        severity: 'low',
        message: 'æœåŠ¡å™¨ä¿¡æ¯æ³„éœ²',
        recommendation: 'éšè—æœåŠ¡å™¨ç‰ˆæœ¬ä¿¡æ¯'
      }
    ];

    // æ·»åŠ ä¸€äº›ç¤ºä¾‹æ¼æ´
    commonVulns.slice(0, 1).forEach(vuln => {
      const vulnerability = {
        id: crypto.randomUUID(),
        ...vuln,
        timestamp: Date.now()
      };
      
      scanResults.vulnerabilities.push(vulnerability);
      scanResults.summary[vuln.severity]++;
    });
  }
}

/**
 * ç»¼åˆæ¼æ´æ‰«æç®¡ç†å™¨
 */
class VulnerabilityScanner {
  constructor(options = {}) {
    this.sastScanner = new SASTScanner(options.sast);
    this.dependencyScanner = new DependencyScanner(options.dependency);
    this.dastScanner = new DASTScanner(options.dast);
    
    this.config = {
      enableSAST: options.enableSAST !== false,
      enableDependencyScanning: options.enableDependencyScanning !== false,
      enableDAST: options.enableDAST !== false,
      ...options
    };
  }

  /**
   * æ‰§è¡Œå®Œæ•´çš„æ¼æ´æ‰«æ
   */
  async performComprehensiveScan() {
    console.log('ğŸ”’ å¼€å§‹ç»¼åˆæ¼æ´æ‰«æ...');
    console.log('=' .repeat(50));
    
    const results = {
      timestamp: Date.now(),
      scanTypes: [],
      totalVulnerabilities: 0,
      summary: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0
      },
      scans: {},
      recommendations: [],
      securityScore: 0
    };

    try {
      // SASTæ‰«æ
      if (this.config.enableSAST) {
        console.log('\nğŸ“ æ‰§è¡ŒSASTæ‰«æ...');
        results.scans.sast = await this.sastScanner.performScan();
        results.scanTypes.push('SAST');
        this.aggregateResults(results, results.scans.sast);
      }

      // ä¾èµ–é¡¹æ‰«æ
      if (this.config.enableDependencyScanning) {
        console.log('\nğŸ“¦ æ‰§è¡Œä¾èµ–é¡¹æ‰«æ...');
        results.scans.dependency = await this.dependencyScanner.performScan();
        results.scanTypes.push('Dependency');
        this.aggregateResults(results, results.scans.dependency);
      }

      // DASTæ‰«æ
      if (this.config.enableDAST) {
        console.log('\nğŸŒ æ‰§è¡ŒDASTæ‰«æ...');
        results.scans.dast = await this.dastScanner.performScan();
        results.scanTypes.push('DAST');
        this.aggregateResults(results, results.scans.dast);
      }

      // ç”Ÿæˆç»¼åˆå»ºè®®
      results.recommendations = this.generateRecommendations(results);
      
      // è®¡ç®—å®‰å…¨è¯„åˆ†
      results.securityScore = this.calculateSecurityScore(results);

      return results;

    } catch (error) {
      console.error('âŒ æ‰«æè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error);
      throw error;
    }
  }

  /**
   * èšåˆæ‰«æç»“æœ
   */
  aggregateResults(mainResults, scanResults) {
    if (scanResults.vulnerabilities) {
      mainResults.totalVulnerabilities += scanResults.vulnerabilities.length;
      
      // èšåˆä¸¥é‡ç¨‹åº¦ç»Ÿè®¡
      Object.keys(mainResults.summary).forEach(severity => {
        mainResults.summary[severity] += scanResults.summary[severity] || 0;
      });
    }
  }

  /**
   * ç”Ÿæˆç»¼åˆå»ºè®®
   */
  generateRecommendations(results) {
    const recommendations = [];

    // åŸºäºæ¼æ´æ•°é‡çš„å»ºè®®
    if (results.summary.critical > 0) {
      recommendations.push({
        priority: 'critical',
        message: `å‘ç°${results.summary.critical}ä¸ªä¸¥é‡æ¼æ´ï¼Œéœ€è¦ç«‹å³ä¿®å¤`,
        action: 'ä¼˜å…ˆä¿®å¤æ‰€æœ‰ä¸¥é‡çº§åˆ«çš„å®‰å…¨æ¼æ´'
      });
    }

    if (results.summary.high > 5) {
      recommendations.push({
        priority: 'high',
        message: `å‘ç°${results.summary.high}ä¸ªé«˜å±æ¼æ´`,
        action: 'åˆ¶å®šä¿®å¤è®¡åˆ’ï¼Œå°½å¿«è§£å†³é«˜å±æ¼æ´'
      });
    }

    // åŸºäºæ‰«æç±»å‹çš„å»ºè®®
    if (results.scans.sast && results.scans.sast.vulnerabilities.length > 0) {
      recommendations.push({
        priority: 'medium',
        message: 'ä»£ç ä¸­å­˜åœ¨å®‰å…¨é—®é¢˜',
        action: 'å®¡æŸ¥ä»£ç ï¼Œå®æ–½å®‰å…¨ç¼–ç æœ€ä½³å®è·µ'
      });
    }

    if (results.scans.dependency && results.scans.dependency.vulnerabilities.length > 0) {
      recommendations.push({
        priority: 'medium',
        message: 'ä¾èµ–é¡¹å­˜åœ¨å·²çŸ¥æ¼æ´',
        action: 'æ›´æ–°ä¾èµ–é¡¹åˆ°å®‰å…¨ç‰ˆæœ¬'
      });
    }

    // é€šç”¨å®‰å…¨å»ºè®®
    if (results.securityScore < 80) {
      recommendations.push({
        priority: 'medium',
        message: 'æ•´ä½“å®‰å…¨è¯„åˆ†è¾ƒä½',
        action: 'å®æ–½å…¨é¢çš„å®‰å…¨åŠ å›ºæªæ–½'
      });
    }

    return recommendations;
  }

  /**
   * è®¡ç®—å®‰å…¨è¯„åˆ†
   */
  calculateSecurityScore(results) {
    let score = 100;

    // æ ¹æ®æ¼æ´ä¸¥é‡ç¨‹åº¦æ‰£åˆ†
    score -= results.summary.critical * 20;
    score -= results.summary.high * 10;
    score -= results.summary.medium * 5;
    score -= results.summary.low * 2;
    score -= results.summary.info * 1;

    // ç¡®ä¿åˆ†æ•°ä¸ä½äº0
    return Math.max(0, score);
  }

  /**
   * ç”Ÿæˆæ‰«ææŠ¥å‘Š
   */
  generateReport(results) {
    const report = {
      ...results,
      generatedAt: new Date().toISOString(),
      scanDuration: Date.now() - results.timestamp,
      riskLevel: this.calculateRiskLevel(results),
      nextScanRecommended: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString() // 7å¤©å
    };

    return report;
  }

  /**
   * è®¡ç®—é£é™©ç­‰çº§
   */
  calculateRiskLevel(results) {
    if (results.summary.critical > 0) return 'Critical';
    if (results.summary.high > 3) return 'High';
    if (results.summary.medium > 5) return 'Medium';
    return 'Low';
  }
}

module.exports = {
  VulnerabilityScanner,
  SASTScanner,
  DependencyScanner,
  DASTScanner
};