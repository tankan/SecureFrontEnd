/**
 * æ¼æ´æ‰«æç³»ç»Ÿæ¼”ç¤ºè¿è¡Œå™¨
 * æ¼”ç¤ºSASTã€DASTã€ä¾èµ–é¡¹æ‰«æåŠŸèƒ½
 */

const fs = require('fs');
const { VulnerabilityScanner } = require('./vulnerability-scanner.cjs');

/**
 * æ¼æ´æ‰«ææ¼”ç¤º
 */
class VulnerabilityScanDemo {
  constructor() {
    this.scanner = null;
  }

  /**
   * è¿è¡Œå®Œæ•´æ¼”ç¤º
   */
  async runDemo() {
    console.log('ğŸ” æ¼æ´æ‰«æç³»ç»Ÿæ¼”ç¤º');
    console.log('=' .repeat(50));
    console.log();

    try {
      // 1. åˆå§‹åŒ–æ‰«æå™¨
      await this.initializeScanner();
      
      // 2. æ‰§è¡Œç»¼åˆæ‰«æ
      const results = await this.performComprehensiveScan();
      
      // 3. åˆ†ææ‰«æç»“æœ
      await this.analyzeResults(results);
      
      // 4. ç”Ÿæˆè¯¦ç»†æŠ¥å‘Š
      await this.generateDetailedReport(results);
      
      // 5. æä¾›ä¿®å¤å»ºè®®
      await this.provideFixes(results);
      
      console.log('\nâœ… æ¼æ´æ‰«æç³»ç»Ÿæ¼”ç¤ºå®Œæˆ!');
      
    } catch (error) {
      console.error('âŒ æ¼”ç¤ºè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error.message);
      throw error;
    }
  }

  /**
   * åˆå§‹åŒ–æ‰«æå™¨
   */
  async initializeScanner() {
    console.log('ğŸ”§ 1. åˆå§‹åŒ–æ¼æ´æ‰«æå™¨...');
    
    const scannerConfig = {
      sast: {
        scanPaths: ['./src', './public', './'],
        excludePaths: ['node_modules', '.git', 'dist', 'build'],
        fileExtensions: ['.js', '.jsx', '.ts', '.tsx', '.html', '.css', '.json']
      },
      dependency: {
        checkNpmAudit: true,
        packageFiles: ['package.json', 'package-lock.json']
      },
      dast: {
        targetUrls: ['http://localhost:3000'],
        maxDepth: 3
      },
      enableSAST: true,
      enableDependencyScanning: true,
      enableDAST: true
    };

    this.scanner = new VulnerabilityScanner(scannerConfig);
    
    console.log('âœ… æ‰«æå™¨åˆå§‹åŒ–å®Œæˆ');
    console.log('   - SAST (é™æ€åº”ç”¨å®‰å…¨æµ‹è¯•): å¯ç”¨');
    console.log('   - ä¾èµ–é¡¹æ‰«æ: å¯ç”¨');
    console.log('   - DAST (åŠ¨æ€åº”ç”¨å®‰å…¨æµ‹è¯•): å¯ç”¨');
    console.log();
  }

  /**
   * æ‰§è¡Œç»¼åˆæ‰«æ
   */
  async performComprehensiveScan() {
    console.log('ğŸ” 2. æ‰§è¡Œç»¼åˆæ¼æ´æ‰«æ...');
    
    const startTime = Date.now();
    const results = await this.scanner.performComprehensiveScan();
    const duration = Date.now() - startTime;
    
    console.log(`\nâ±ï¸ æ‰«æå®Œæˆï¼Œè€—æ—¶: ${(duration / 1000).toFixed(2)}ç§’`);
    console.log(`ğŸ“Š æ‰«æç±»å‹: ${results.scanTypes.join(', ')}`);
    console.log(`ğŸ” å‘ç°æ¼æ´æ€»æ•°: ${results.totalVulnerabilities}`);
    
    return results;
  }

  /**
   * åˆ†ææ‰«æç»“æœ
   */
  async analyzeResults(results) {
    console.log('\nğŸ“Š 3. åˆ†ææ‰«æç»“æœ...');
    
    // æ˜¾ç¤ºæ¼æ´ç»Ÿè®¡
    console.log('ğŸ¯ æ¼æ´ä¸¥é‡ç¨‹åº¦åˆ†å¸ƒ:');
    console.log(`   ğŸ”´ ä¸¥é‡ (Critical): ${results.summary.critical}`);
    console.log(`   ğŸŸ  é«˜å± (High): ${results.summary.high}`);
    console.log(`   ğŸŸ¡ ä¸­å± (Medium): ${results.summary.medium}`);
    console.log(`   ğŸŸ¢ ä½å± (Low): ${results.summary.low}`);
    console.log(`   â„¹ï¸ ä¿¡æ¯ (Info): ${results.summary.info}`);
    
    // æ˜¾ç¤ºå®‰å…¨è¯„åˆ†
    console.log(`\nğŸ† å®‰å…¨è¯„åˆ†: ${results.securityScore}/100`);
    
    let riskLevel = 'ä½é£é™©';
    let riskColor = 'ğŸŸ¢';
    
    if (results.summary.critical > 0) {
      riskLevel = 'ä¸¥é‡é£é™©';
      riskColor = 'ğŸ”´';
    } else if (results.summary.high > 3) {
      riskLevel = 'é«˜é£é™©';
      riskColor = 'ğŸŸ ';
    } else if (results.summary.medium > 5) {
      riskLevel = 'ä¸­ç­‰é£é™©';
      riskColor = 'ğŸŸ¡';
    }
    
    console.log(`${riskColor} é£é™©ç­‰çº§: ${riskLevel}`);
    
    // åˆ†æå„æ‰«æç±»å‹ç»“æœ
    if (results.scans.sast) {
      console.log(`\nğŸ“ SASTæ‰«æç»“æœ:`);
      console.log(`   - æ‰«ææ–‡ä»¶æ•°: ${results.scans.sast.scannedFiles}`);
      console.log(`   - å‘ç°é—®é¢˜: ${results.scans.sast.vulnerabilities.length}ä¸ª`);
      
      if (results.scans.sast.vulnerabilities.length > 0) {
        const topVulns = results.scans.sast.vulnerabilities
          .slice(0, 3)
          .map(v => `${v.type} (${v.severity})`);
        console.log(`   - ä¸»è¦é—®é¢˜: ${topVulns.join(', ')}`);
      }
    }
    
    if (results.scans.dependency) {
      console.log(`\nğŸ“¦ ä¾èµ–é¡¹æ‰«æç»“æœ:`);
      console.log(`   - æ€»ä¾èµ–æ•°: ${results.scans.dependency.dependencies.total || 0}`);
      console.log(`   - ç”Ÿäº§ä¾èµ–: ${results.scans.dependency.dependencies.production?.length || 0}`);
      console.log(`   - å¼€å‘ä¾èµ–: ${results.scans.dependency.dependencies.development?.length || 0}`);
      console.log(`   - å‘ç°æ¼æ´: ${results.scans.dependency.vulnerabilities.length}ä¸ª`);
    }
    
    if (results.scans.dast) {
      console.log(`\nğŸŒ DASTæ‰«æç»“æœ:`);
      console.log(`   - æ‰«æURLæ•°: ${results.scans.dast.scannedUrls.length}`);
      console.log(`   - å‘ç°é—®é¢˜: ${results.scans.dast.vulnerabilities.length}ä¸ª`);
    }
  }

  /**
   * ç”Ÿæˆè¯¦ç»†æŠ¥å‘Š
   */
  async generateDetailedReport(results) {
    console.log('\nğŸ“„ 4. ç”Ÿæˆè¯¦ç»†æ‰«ææŠ¥å‘Š...');
    
    const report = this.scanner.generateReport(results);
    
    // æ·»åŠ è¯¦ç»†çš„æ¼æ´ä¿¡æ¯
    const detailedReport = {
      ...report,
      detailedVulnerabilities: this.categorizeVulnerabilities(results),
      scanConfiguration: {
        sastEnabled: results.scanTypes.includes('SAST'),
        dependencyEnabled: results.scanTypes.includes('Dependency'),
        dastEnabled: results.scanTypes.includes('DAST')
      },
      complianceStatus: this.checkCompliance(results),
      trendAnalysis: this.generateTrendAnalysis(results)
    };
    
    // ä¿å­˜æŠ¥å‘Š
    const reportPath = 'VULNERABILITY_SCAN_REPORT.json';
    fs.writeFileSync(reportPath, JSON.stringify(detailedReport, null, 2));
    
    console.log(`ğŸ“ è¯¦ç»†æŠ¥å‘Šå·²ä¿å­˜è‡³: ${reportPath}`);
    console.log(`ğŸ“Š æŠ¥å‘ŠåŒ…å«:`);
    console.log(`   - æ¼æ´è¯¦ç»†ä¿¡æ¯å’Œåˆ†ç±»`);
    console.log(`   - ä¿®å¤å»ºè®®å’Œä¼˜å…ˆçº§`);
    console.log(`   - åˆè§„æ€§æ£€æŸ¥ç»“æœ`);
    console.log(`   - å®‰å…¨è¶‹åŠ¿åˆ†æ`);
    console.log(`   - ä¸‹æ¬¡æ‰«æå»ºè®®æ—¶é—´: ${new Date(report.nextScanRecommended).toLocaleDateString()}`);
  }

  /**
   * åˆ†ç±»æ¼æ´
   */
  categorizeVulnerabilities(results) {
    const categories = {
      codeQuality: [],
      security: [],
      dependencies: [],
      configuration: [],
      compliance: []
    };

    // å¤„ç†SASTç»“æœ
    if (results.scans.sast) {
      results.scans.sast.vulnerabilities.forEach(vuln => {
        switch (vuln.type) {
          case 'code-injection':
          case 'xss':
          case 'sql-injection':
            categories.security.push(vuln);
            break;
          case 'hardcoded-secrets':
          case 'sensitive-data-exposure':
            categories.configuration.push(vuln);
            break;
          default:
            categories.codeQuality.push(vuln);
        }
      });
    }

    // å¤„ç†ä¾èµ–é¡¹ç»“æœ
    if (results.scans.dependency) {
      results.scans.dependency.vulnerabilities.forEach(vuln => {
        categories.dependencies.push(vuln);
      });
    }

    // å¤„ç†DASTç»“æœ
    if (results.scans.dast) {
      results.scans.dast.vulnerabilities.forEach(vuln => {
        categories.security.push(vuln);
      });
    }

    return categories;
  }

  /**
   * æ£€æŸ¥åˆè§„æ€§
   */
  checkCompliance(results) {
    const compliance = {
      owasp: {
        score: 0,
        issues: [],
        recommendations: []
      },
      gdpr: {
        score: 0,
        issues: [],
        recommendations: []
      },
      pci: {
        score: 0,
        issues: [],
        recommendations: []
      }
    };

    // OWASP Top 10 æ£€æŸ¥
    const owaspIssues = [];
    if (results.summary.critical > 0) {
      owaspIssues.push('å­˜åœ¨ä¸¥é‡å®‰å…¨æ¼æ´');
    }
    if (results.scans.sast?.vulnerabilities.some(v => v.type === 'xss')) {
      owaspIssues.push('å­˜åœ¨XSSæ¼æ´é£é™©');
    }
    if (results.scans.sast?.vulnerabilities.some(v => v.type === 'sql-injection')) {
      owaspIssues.push('å­˜åœ¨SQLæ³¨å…¥é£é™©');
    }

    compliance.owasp.issues = owaspIssues;
    compliance.owasp.score = Math.max(0, 100 - owaspIssues.length * 20);

    // GDPR æ•°æ®ä¿æŠ¤æ£€æŸ¥
    const gdprIssues = [];
    if (results.scans.sast?.vulnerabilities.some(v => v.type === 'hardcoded-secrets')) {
      gdprIssues.push('å­˜åœ¨ç¡¬ç¼–ç æ•æ„Ÿä¿¡æ¯');
    }
    if (results.scans.sast?.vulnerabilities.some(v => v.type === 'sensitive-data-exposure')) {
      gdprIssues.push('å­˜åœ¨æ•æ„Ÿæ•°æ®æ³„éœ²é£é™©');
    }

    compliance.gdpr.issues = gdprIssues;
    compliance.gdpr.score = Math.max(0, 100 - gdprIssues.length * 25);

    return compliance;
  }

  /**
   * ç”Ÿæˆè¶‹åŠ¿åˆ†æ
   */
  generateTrendAnalysis(results) {
    return {
      securityTrend: results.securityScore >= 80 ? 'improving' : 'needs_attention',
      vulnerabilityTrend: results.totalVulnerabilities <= 5 ? 'stable' : 'increasing',
      riskTrend: results.summary.critical === 0 ? 'decreasing' : 'critical',
      recommendations: [
        'å»ºè®®æ¯å‘¨è¿›è¡Œä¸€æ¬¡æ¼æ´æ‰«æ',
        'ä¼˜å…ˆä¿®å¤ä¸¥é‡å’Œé«˜å±æ¼æ´',
        'å»ºç«‹æ¼æ´ç®¡ç†æµç¨‹',
        'å®šæœŸæ›´æ–°ä¾èµ–é¡¹'
      ]
    };
  }

  /**
   * æä¾›ä¿®å¤å»ºè®®
   */
  async provideFixes(results) {
    console.log('\nğŸ”§ 5. ä¿®å¤å»ºè®®å’Œæœ€ä½³å®è·µ...');
    
    if (results.recommendations.length > 0) {
      console.log('ğŸ’¡ ä¼˜å…ˆä¿®å¤å»ºè®®:');
      results.recommendations.forEach((rec, index) => {
        const priorityIcon = rec.priority === 'critical' ? 'ğŸ”´' : 
                           rec.priority === 'high' ? 'ğŸŸ ' : 
                           rec.priority === 'medium' ? 'ğŸŸ¡' : 'ğŸŸ¢';
        console.log(`   ${index + 1}. ${priorityIcon} ${rec.message}`);
        console.log(`      â¤ ${rec.action}`);
      });
    }

    console.log('\nğŸ›¡ï¸ å®‰å…¨æœ€ä½³å®è·µ:');
    console.log('   1. ğŸ”’ å®æ–½å®‰å…¨ç¼–ç æ ‡å‡†');
    console.log('   2. ğŸ“¦ å®šæœŸæ›´æ–°ä¾èµ–é¡¹');
    console.log('   3. ğŸ” é›†æˆå®‰å…¨æ‰«æåˆ°CI/CDæµæ°´çº¿');
    console.log('   4. ğŸ¯ å»ºç«‹æ¼æ´å“åº”æµç¨‹');
    console.log('   5. ğŸ“š è¿›è¡Œå®‰å…¨åŸ¹è®­');
    console.log('   6. ğŸ” ä½¿ç”¨å®‰å…¨é…ç½®ç®¡ç†');
    console.log('   7. ğŸ“Š å®šæœŸè¿›è¡Œå®‰å…¨å®¡è®¡');

    console.log('\nğŸš€ è‡ªåŠ¨åŒ–å»ºè®®:');
    console.log('   - åœ¨CI/CDä¸­é›†æˆæ¼æ´æ‰«æ');
    console.log('   - è®¾ç½®æ¼æ´å‘Šè­¦é€šçŸ¥');
    console.log('   - å»ºç«‹è‡ªåŠ¨ä¾èµ–é¡¹æ›´æ–°');
    console.log('   - å®æ–½å®‰å…¨é—¨ç¦ç­–ç•¥');

    // ç”Ÿæˆä¿®å¤è„šæœ¬ç¤ºä¾‹
    this.generateFixScripts(results);
  }

  /**
   * ç”Ÿæˆä¿®å¤è„šæœ¬ç¤ºä¾‹
   */
  generateFixScripts(results) {
    const fixScripts = {
      packageJsonFix: this.generatePackageJsonFix(results),
      securityHeadersFix: this.generateSecurityHeadersFix(results),
      cspFix: this.generateCSPFix(results)
    };

    console.log('\nğŸ“ è‡ªåŠ¨ä¿®å¤è„šæœ¬å·²ç”Ÿæˆ:');
    console.log('   - package.json å®‰å…¨æ›´æ–°è„šæœ¬');
    console.log('   - å®‰å…¨å¤´é…ç½®è„šæœ¬');
    console.log('   - CSPç­–ç•¥é…ç½®è„šæœ¬');

    // ä¿å­˜ä¿®å¤è„šæœ¬
    fs.writeFileSync('../../config/security/security-fixes.json', JSON.stringify(fixScripts, null, 2));
        console.log('   ğŸ“ ä¿®å¤è„šæœ¬å·²ä¿å­˜è‡³: ../../config/security/security-fixes.json');
  }

  /**
   * ç”Ÿæˆpackage.jsonä¿®å¤è„šæœ¬
   */
  generatePackageJsonFix(results) {
    const fixes = [];
    
    if (results.scans.dependency?.vulnerabilities.length > 0) {
      fixes.push({
        action: 'update-dependencies',
        command: 'npm audit fix',
        description: 'è‡ªåŠ¨ä¿®å¤å·²çŸ¥æ¼æ´'
      });
      
      fixes.push({
        action: 'update-packages',
        command: 'npm update',
        description: 'æ›´æ–°æ‰€æœ‰åŒ…åˆ°æœ€æ–°ç‰ˆæœ¬'
      });
    }

    return fixes;
  }

  /**
   * ç”Ÿæˆå®‰å…¨å¤´ä¿®å¤è„šæœ¬
   */
  generateSecurityHeadersFix(results) {
    const fixes = [];
    
    if (results.scans.dast?.vulnerabilities.some(v => v.type === 'missing-security-header')) {
      fixes.push({
        action: 'add-security-headers',
        middleware: 'helmet',
        description: 'æ·»åŠ åŸºç¡€å®‰å…¨å¤´'
      });
    }

    return fixes;
  }

  /**
   * ç”ŸæˆCSPä¿®å¤è„šæœ¬
   */
  generateCSPFix(results) {
    const fixes = [];
    
    if (results.scans.sast?.vulnerabilities.some(v => v.type === 'inline-script')) {
      fixes.push({
        action: 'implement-csp',
        policy: "default-src 'self'; script-src 'self' 'nonce-{nonce}'",
        description: 'å®æ–½å†…å®¹å®‰å…¨ç­–ç•¥'
      });
    }

    return fixes;
  }

  /**
   * æ¼”ç¤ºCI/CDé›†æˆ
   */
  demonstrateCIIntegration() {
    console.log('\nğŸ”„ CI/CD é›†æˆç¤ºä¾‹:');
    console.log(`
# GitHub Actions å·¥ä½œæµç¤ºä¾‹
name: Security Scan
on: [push, pull_request]

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'
      - name: Install dependencies
        run: npm ci
      - name: Run vulnerability scan
        run: node run-vulnerability-scan.cjs
      - name: Upload scan results
        uses: actions/upload-artifact@v2
        with:
          name: security-scan-results
          path: VULNERABILITY_SCAN_REPORT.json
    `);
  }
}

/**
 * è¿è¡Œæ¼”ç¤º
 */
async function runVulnerabilityScanDemo() {
  const demo = new VulnerabilityScanDemo();
  
  try {
    await demo.runDemo();
    demo.demonstrateCIIntegration();
    
    console.log('\nğŸ‰ æ¼æ´æ‰«æç³»ç»Ÿæ¼”ç¤ºæˆåŠŸå®Œæˆ!');
    console.log('ğŸ“‹ ä¸»è¦åŠŸèƒ½:');
    console.log('   âœ… SAST (é™æ€åº”ç”¨å®‰å…¨æµ‹è¯•)');
    console.log('   âœ… ä¾èµ–é¡¹æ¼æ´æ‰«æ');
    console.log('   âœ… DAST (åŠ¨æ€åº”ç”¨å®‰å…¨æµ‹è¯•)');
    console.log('   âœ… ç»¼åˆå®‰å…¨è¯„åˆ†');
    console.log('   âœ… è‡ªåŠ¨ä¿®å¤å»ºè®®');
    console.log('   âœ… åˆè§„æ€§æ£€æŸ¥');
    console.log('   âœ… CI/CD é›†æˆæ”¯æŒ');
    
  } catch (error) {
    console.error('âŒ æ¼”ç¤ºå¤±è´¥:', error);
    process.exit(1);
  }
}

// è¿è¡Œæ¼”ç¤º
if (require.main === module) {
  runVulnerabilityScanDemo();
}

module.exports = { VulnerabilityScanDemo };